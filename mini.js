function createCanvas(id) {
    var tempCanvas = document.createElement("canvas");
    tempCanvas.id = id;
    tempCanvas.width = canvases.cvs.width;
    tempCanvas.height = canvases.cvs.height;
    tempCanvas.style = "image-rendering:pixelated;image-rendering: crisp-edges;display:none";//display:none;

    document.body.appendChild(tempCanvas);

    canvases[`${id}cvs`] = document.getElementById(id);
    canvases[`${id}ctx`] = canvases[`${id}cvs`].getContext("2d");
}

function startLoops() {
    try {draw} catch (err){console.warn(bug+" no draw function found");return null;}
    try {update} catch (err){console.warn(bug+" no update function found");return null;}
    try {input} catch (err){seperateInputLoop=false;}
    onAssetsLoaded();

    requestAnimationFrame(drawLoop);
    setInterval(updateLoop,1000/updateFPS);

    if(seperateInputLoop) {
        setInterval(inputLoop,4);
    }
}

function mousePosition() {
    if(drawMode===0) {
        return {x:(mousePos.x)-camera.x,y:(mousePos.y)-camera.y};
    } else if(drawMode===1) {
        var xoff = canvases.cvs.width/2;
        var yoff = canvases.cvs.height/2;
        return {x:((mousePos.x-xoff)/camera.zoom+xoff)-camera.x,y:((mousePos.y-yoff)/camera.zoom+yoff)-camera.y};
    } else {
        var xoff = canvases.cvs.width/2;
        var yoff = canvases.cvs.height/2;
        var tempPos = {x:((mousePos.x-xoff)/camera.zoom+xoff)-camera.x,y:((mousePos.y-yoff)/camera.zoom+yoff)-camera.y};

        var center = {x:-camera.x + cw/2, y:-camera.y + ch/2};
        var tempAngle = pointTo(center,tempPos) - camera.angle; 
        var tempDist = dist(center,tempPos);

        return {x:center.x + (Math.cos(tempAngle) * tempDist),y:center.y + (Math.sin(tempAngle) * tempDist)}
    }
}

function addStyle() {
    var tempStyle = document.createElement("style");
    tempStyle.id="gamejsstyle";
    document.head.appendChild(tempStyle);
    var tempMeta = document.createElement("meta");
    tempMeta.setAttribute("charset","utf-8");
    document.head.appendChild(tempMeta);
}

function rand(min,max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function radToDeg(rad) {return rad / Math.PI * 180;}
function degToRad(deg) {return deg * Math.PI / 180;}

function velocity(angle) {
    return {x:Math.sin(angle),y:Math.cos(angle)};
}

function pointTo(point,targetPoint) {
    var adjacent = (targetPoint.x - point.x);
    var opposite = (targetPoint.y - point.y);
    var h = Math.atan2(opposite, adjacent);
    return h;
}

function loadImagesAndSounds() {
    var curpath="";
    context = new AudioContext();
    sfxVolumeNode = context.createGain();
    sfxVolumeNode.connect(context.destination);
    bmgVolumeNode = context.createGain();
    bmgVolumeNode.connect(context.destination);
    deeper(images,"image");
    deeper(audio,"sound");
    function deeper(curpos,type) {
        let addedPath="";
        for(let j=0;j<curpos.length;j++) {
            if(typeof curpos[j]=="string") {
                if(j==0) {
                    curpath+=curpos[j];
                    addedPath = curpos[j];
                } else {
                    if(type=="image") {
                        let name = curpath + curpos[j];
                        imagePaths.push(name);
                        let temp = new Image();
                        temp.src = name;
                        temp.onerror = function () {
                            console.warn(bug+" "+this.src + " was not found");
                        };
                        temp.onload = function() {spriteLoad(name,temp);}
                        imgs.push(temp);
                    } else if(type=="sound") {
                        audioPaths.push(curpath + curpos[j]);
                        newSound(curpath + curpos[j]);
                    }
                }
            }
            if(typeof curpos[j]=="object") {
               deeper(curpos[j],type);
            }
        }
        curpath = curpath.slice(0,curpath.length-addedPath.length);
    }
    
    loadingCircle = new Image();
    loadingCircle.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAf0lEQVQ4jc2SuxHAIAxDbY4pMpHmyJSeKGuQKpyj2Hy6qETPQvhQCWRmDRfeZ4cJAGW28mAUyL4Pqmx2nfK+zaR59glRHo5qZi0BaPHmbDhiyuzdsza9wcrtEVtG4Ip+FLCzTM+WneWxPv9gpQUzmhncLPOHUCYfHr4/C4r2dQPfhkeIbjeYWgAAAABJRU5ErkJggg==";
    clickSound = new Audio("data:audio/x-wav;base64,UklGRowBAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWgBAADa/6T/2/+S/x//pP769Xr4fPh5+H34evh7+Pv6gf18/QIAhQcIDxUZFR4VHhgeEx6TFgkPCgqAAnz49/X18HLu7ubo4eXc5dzj3Gjf5+Fr5G7pce759YECiwwRFBQZlxuXG5cbFRmTFo8RCAoAAPz69/X08G7udO5s7vz1dvj++nv9gP3+/wEAgwKBAogHkBEpLUNG1lzqcPV683r4eu51ZmnVV7w+qypy88fDoKAXlAqKBoUAgIeHlpYsrTu87Ot9/ZIRGxkoKDEtqionIxgZiwfj5lnaz9JN0E3QV9pd3+Tm9fUBAAQFBwWNDBEPFxSYFpsWEA9+/fP1dfNt83bz8fX9+gQFkAwPDxQPEQ+IBwIAdfjv8OLm2+HX3Nrh4+bm63n4BAUUDx0ZqyCrJSkelBGEAnb4a+5a5Njcztxc31jkZunx9QgFGhQfGa0gqCCuIKkgpRsaFIsHdfhj6dfh0NzM19Th6es=");
    let pos = {x:cw/2-100,y:ch/2-100};
    optionsButtons.screenSize = {x:pos.x+160,y:pos.y+12,w:50,h:20};
    optionsButtons.sfx = {x:pos.x+125,y:pos.y+40,w:120,h:20};
    optionsButtons.bmg = {x:pos.x+125,y:pos.y+70,w:120,h:20};
    loadLoop();
}

function loadLoop() {
    if(Object.keys(sprites).length == imagePaths.length && audioPaths.length == audioLoadedLength) {
        startLoops();
        imagePaths=[];
        audioPaths=[];
        imgs=[];
    } else {
        curCtx.fillStyle="#2d2d2d";
        curCtx.fillRect(0,0,cw,ch);
        text(`audio:   ${audioLoadedLength}/${audioPaths.length}`,10,30,"white",2);
        text(`sprites: ${Object.keys(sprites).length}/${imagePaths.length}`,10,10,"white",2);
        curCtx.setTransform(1, 0, 0, 1, Math.round(cw/2), Math.round(ch/2));
        curCtx.rotate(loadAng);
        loadAng+=0.1;
        curCtx.drawImage(loadingCircle,Math.round(-8),Math.round(-8));
        curCtx.setTransform(1, 0, 0, 1, 0, 0);
        requestAnimationFrame(loadLoop);
    }
}

function spriteLoad(path,image) {
    let startpos;
    let endpos = path.lastIndexOf(".");
    for(let j=endpos-1;acceptableChars.includes(path[j]);j--) {startpos=j;}
    let spriteName = path.slice(startpos,endpos)
    let dsize=Math.max(image.width,image.height)/2;
    sprites[spriteName] = {spr:image,drawLimitSize:dsize};
    
}

function newSound(src) {
    let startpos;
    let endpos = src.lastIndexOf(".");
    for(let j=endpos-1;acceptableChars.includes(src[j]);j--) {startpos=j;}
    let soundName = src.slice(startpos,endpos); 
    sounds[soundName] = {nodes:[],volNodes:[],src:src,type:"sfx",volume:1};
    sounds[soundName].nodes = [1];

    let loadingSound = new Audio();
    loadingSound.onerror = function () {
        console.warn(bug+" "+ src + " was not found");
    };
    loadingSound.src = src;
    loadingSound.preload='auto';
    loadingSound.addEventListener('canplaythrough', function() { 
        audioLoadedLength++;
     }, false);
    sounds[soundName].nodes.push(loadingSound);

    let soundNode = context.createMediaElementSource(loadingSound);
    let gainNode = context.createGain();

    soundNode.connect(gainNode);
    gainNode.connect(sfxVolumeNode);

    abuffer.push(soundNode);
    volumeList.push(gainNode);
    sounds[soundName].volNodes.push(volumeList.length-1);
}

function addSound(sound) {
    let loadingSound = new Audio();
    loadingSound.src = sound.src;
    loadingSound.preload='auto';
    sound.nodes.splice(sound.nodes[0],0,loadingSound);

    let soundNode = context.createMediaElementSource(loadingSound);
    let gainNode = context.createGain();
    gainNode.gain.value=sound.volume;

    soundNode.connect(gainNode);
    gainNode.connect(sound.type=="sfx"?sfxVolumeNode:bmgVolumeNode);

    abuffer.push(soundNode);
    volumeList.push(gainNode);
    sound.volNodes.push(volumeList.length-1);

    volumeList[sound.volNodes[sound.volNodes.length-1]].gain.value = volumeList[sound.volNodes[0]].gain.value
}



function play(sound) {
    s=sound.nodes;
    if(s[s[0]].ended || !(s[s[0]].played.length)) {
        s[s[0]].play();
        s[0]++;
        if(s[0]==s.length) {
            s[0]=1;
        }
    } else {
        addSound(sound);
        s[s[0]].play();
        s[0]++;
        if(s[0]==s.length) {
            s[0]=1;
        }
    }
}

function setVolume(sound,volume) {
    for(let i=0,l=sound.volNodes.length;i<l;i++) {
        volumeList[sound.volNodes[i]].gain.value = volume;
    }
}

function setType(sound,newType) {
    for(let i=0,l=sound.volNodes.length;i<l;i++) {
        volumeList[sound.volNodes[i]].disconnect(sound.type=="sfx"?sfxVolumeNode:bmgVolumeNode);
        volumeList[sound.volNodes[i]].connect(newType=="sfx"?sfxVolumeNode:bmgVolumeNode);
    }
    sound.type = newType;
}

function stop(sound) {
    s=sound.nodes;
    for(let i=1;i<s.length;i++) {
        s[i].pause();
        s[i].currentTime = 0;
    }
}

function handleOptionsInput() {
    let ImTierdMakemenuwork=true;
    if(optionsMenu) {
        if(mousePress[0]) {
            if(rectpoint(optionsButtons.screenSize,mousePos)) {
                if(screenSize=="1:1") {
                    screenSize = "fit";
                    canvasScale=0;
                } else {
                    screenSize = "1:1";
                    canvasScale=1;
                }
            }
            if(!rectpoint({x:cw/2,y:ch/2,w:200,h:200},mousePos)) {
                optionsMenu=false;
                ImTierdMakemenuwork=false;
            }
        }
        if(mouseDown[0]) {
            if(rectpoint(optionsButtons.sfx,mousePos)) {
                volume.sfx = (mousePos.x-(optionsButtons.sfx.x-60))/120;
            }
            if(rectpoint(optionsButtons.bmg,mousePos)) {
                volume.bgm = (mousePos.x-(optionsButtons.bmg.x-60))/120;
            }
        }
    }
    if(mousePos.x>cw-32&&mousePos.y<32) {
        if(mousePress[0]&&ImTierdMakemenuwork) {
            clickSound.play();
            paused=true;
            optionsMenu=!optionsMenu;
        }
        optionsHover = 25;
    } else {
        optionsHover = 0;
    }
    if(mousePos.x<cw-32&&mousePos.x>cw-64&&mousePos.y<32) {
        pauseHover = 25;
        if(mousePress[0]) {
            clickSound.play();
            paused=!paused;
        }
    } else {
        pauseHover = 0;
    }
    
}
function addFont() {
    var tempStyle = document.createElement("style");
    tempStyle.innerHTML = `
    @font-face {
        font-family: 'PixelArial11';
        src: url(data:font/truetype;charset=utf-8;base64,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) format('truetype');
        font-weight: 900;
        font-style: normal;
    
    }
    html {font-family: 'PixelArial11' !important; font-size: 16px;}
    `;
    document.head.appendChild(tempStyle);
    canvases.ctx.textBaseline = "hanging";
    canvases.ctx.textAlign = "left";
}
var scaleDefault = 1;
function img(img,x,y,angle=0,sx=scaleDefault,sy=scaleDefault) {
    var half = img.drawLimitSize;
    if((x+half>drawLimitLeft&&x-half<drawLimitRight&&y+half>drawLimitTop&&y-half<drawLimitBottom)||absDraw) {
        let spr = img.spr;
        if(angle===0&&sx===1&&sy===1) {
            curCtx.drawImage(spr,Math.round(x+camera.x+difx-(spr.width/2)),Math.round(y+camera.y+dify-(spr.height/2)));
        } else {
            curCtx.setTransform(sx, 0, 0, sy, Math.round(x+camera.x+difx), Math.round(y+camera.y+dify));
            curCtx.rotate(angle);
            curCtx.drawImage(spr,Math.round(-spr.width/2),Math.round(-spr.height/2));
            curCtx.setTransform(1, 0, 0, 1, 0, 0);
        }
    }
}

function imgIgnoreCutoff(img,x,y,angle=0,sx=1,sy=1) {
    let spr = img.spr;
    if(angle===0&&sx===1&&sy===1) {
        curCtx.drawImage(spr,Math.round(x+camera.x+difx-(spr.width/2)),Math.round(y+camera.y+dify-(spr.height/2)));
    } else {
        curCtx.setTransform(sx, 0, 0, sy, Math.round(x+camera.x+difx), Math.round(y+camera.y+dify));
        curCtx.rotate(angle);
        curCtx.drawImage(spr,Math.round(-spr.width/2),Math.round(-spr.height/2));
        curCtx.setTransform(1, 0, 0, 1, 0, 0);
    }
}

function rect(x,y,w,h,color) {
    curCtx.fillStyle = color;
    curCtx.fillRect(x-(w/2)+camera.x+difx,y-(h/2)+camera.y+dify,w,h);
}

function circle(x,y,r,color) {
    curCtx.beginPath();
    curCtx.arc(x+camera.x+difx, y+camera.y+dify, r, 0, 2 * Math.PI, false);
    curCtx.fillStyle = color;
    curCtx.fill();
}

function shape(x,y,relitivePoints,color) {
    x+=camera.x+difx;
    y+=camera.y+dify;
    curCtx.fillStyle = color;
    curCtx.beginPath();
    curCtx.moveTo(x+relitivePoints[0].x, y+relitivePoints[0].y);
    for(let i=1,l=relitivePoints.length;i<l;i++) {
        curCtx.lineTo(x+relitivePoints[i].x, y+relitivePoints[i].y);
    }
    curCtx.fill();
}

function text(txt,x,y,color="black",size=1,maxWidth=cw) {
    txt = txt.toString();
    curCtx.fillStyle = color;
    curCtx.font = `${Math.round(size)*8}px PixelArial11`;
                                                                                        //I hate text wrapping now 
    var txtList = txt.split("\n");                                                      //split string on enters
    for(let i=0;i<txtList.length;i++) {                                                 //go through array of strings
        if(curCtx.measureText(txtList[i]).width>maxWidth) {                             //if the string is too big, divide up into smaller strings
            var tempTxt = txtList[i].split(" ");                                        //split into individual words
            var tempStr="";                                                             //string for measuring size
            var addAmount=0;                                                            //track where in the txtList we are
            txtList.splice(i,1);                                                        //remove the too long string
            for(let j=0;j<tempTxt.length;j++) {                                         //go through the split up string
                if(curCtx.measureText(tempStr + tempTxt[j] + " ").width<maxWidth) {     //if adding a word doesn't make tempStr too long, add it, other wise, add tempStr to txtList;
                    tempStr += tempTxt[j] + " ";
                } else {
                    if(j==0) {tempStr+=tempTxt[j];}                                     //if we are here when j is 0, we have one word that is longer then the maxWidth, so we just draw it
                    txtList.splice(i+addAmount,0,tempStr);                              //put tempStr in txtList
                    addAmount++;                                                        //move the position we put the tempStr in
                    tempStr="";                                                         //reset tempStr
                    tempTxt.splice(0,(j==0?1:j));                                       //delete words that have been used
                    j=-1;                                                               //make it so in the next loop, j starts at 0
                }
            }
            if(tempStr.length!=0) {
                txtList.splice(i+addAmount,0,tempStr);                                  //add any leftover text
            }
        }
    }

    for(let i=0;i<txtList.length;i++) {
        curCtx.fillText(txtList[i],x+camera.x+difx,y+camera.y+dify+((i+(drawMode?1:0))*8*size+(size*i)));
    }
}

function textWidth(txt,size=1) {
    txt = txt.toString();
    curCtx.font = `${Math.round(size)*8}px PixelArial11`;
    return curCtx.measureText(txt).width;
}

function centerCameraOn(x,y) {
    camera.x = -x+canvases.cvs.width/2;
    camera.y = -y+canvases.cvs.height/2;
}

function moveCamera(x,y) {
    camera.x -= y * Math.sin(camera.angle);
    camera.y -= y * Math.cos(camera.angle);
    camera.x -= x * Math.sin(camera.angle + 1.57079632);
    camera.y -= x * Math.cos(camera.angle + 1.57079632);
}

function imgRotScale(x,y,angle,scale,pic,ctx) { //used for camera movement
    ctx.setTransform(scale, 0, 0, scale, x, y);
    ctx.rotate(angle);
    ctx.drawImage(pic,-pic.width/2,-pic.height/2);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function drawCursor() {
    if(cursor.sprite&&mouseOnCanvas) {
        if(cursor.alignment) {
            canvases.ctx.drawImage(cursor.sprite.spr,mousePos.x-Math.round(cursor.sprite.spr.width/2),mousePos.y-Math.round(cursor.sprite.spr.height/2));
        } else {
            canvases.ctx.drawImage(cursor.sprite.spr,mousePos.x,mousePos.y);
        }
        cursor.show = false;
    } else {
        cursor.show = true;
    }
}

function render() {
    if(drawMode===1) {
        imgRotScale(canvases.cvs.width/2,canvases.cvs.height/2,0,camera.zoom,canvases.buffer1cvs,canvases.ctx);
    }
    if(drawMode===2) {
        imgRotScale(canvases.cvs.width/2,canvases.cvs.height/2,camera.angle,1,canvases.buffer2cvs,canvases.buffer1ctx);
        imgRotScale(canvases.cvs.width/2,canvases.cvs.height/2,0,camera.zoom,canvases.buffer1cvs,canvases.ctx);
    }
}

function clearCanvases() {
    canvases.ctx.clearRect(0,0,canvases.cvs.width,canvases.cvs.height);
    canvases.buffer1ctx.clearRect(0,0,canvases.buffer1cvs.width,canvases.buffer1cvs.height);
    canvases.buffer2ctx.clearRect(0,0,canvases.buffer2cvs.width,canvases.buffer2cvs.height);
}

function switchDrawMode() {
    if(camera.zoom<1) {camera.zoom=1;}
    if(camera.angle!=0) {
        drawMode=2;
    } else if(camera.zoom!=1) {
        drawMode=1;
    } else {
        drawMode=0;
    }
    switch (drawMode) {
        case 0: curCtx = canvases.ctx; break;
        case 1: curCtx = canvases.buffer1ctx; break;
        case 2: curCtx = canvases.buffer2ctx; break;
    }
}

function resizeBuffers() {
    var tempSize = maxCvsSize/camera.zoom;
    var tempSizeAndPadding = tempSize + (tempSize/2)

    canvases.buffer2cvs.width = tempSizeAndPadding;
    canvases.buffer2cvs.height = tempSizeAndPadding;
    
    if(drawMode===2) {
        difx = (canvases.buffer2cvs.width - canvases.cvs.width)/2;
        dify = (canvases.buffer2cvs.height - canvases.cvs.height)/2;
    } else {
        difx=0;
        dify=0;
    }
    canvases.buffer2ctx.imageSmoothingEnabled = false;
}

function scaleCanvases() { //scales canvas by canvas scale, if scale is 0, canvas will try to fit screen
    var style = document.getElementById("gamejsstyle");
    if(canvasScale==0) {
        var tempScale = Math.min(Math.floor(window.innerWidth/canvases.cvs.width),Math.floor(window.innerHeight/canvases.cvs.height));
        tempScale=tempScale<1?1:tempScale;
        autoScale=tempScale;
        // style.innerHTML = `#game {image-rendering:pixelated;image-rendering: crisp-edges;width:${tempScale*canvases.cvs.width}px;cursor: ${cursor.show?"crosshair":"none"};}`;
    } else {
        // style.innerHTML = `#game {image-rendering:pixelated;image-rendering: crisp-edges;width:${Math.floor(canvasScale*canvases.cvs.width)}px;cursor: ${cursor.show?"crosshair":"none"};}`;
    }
}

function drawButtons() {
    let pos = {x:cw-16,y:16}; 
    //options
    rect(pos.x,pos.y,34,34,"#9c9c9c");
    let c = optionsHover+45;
    rect(pos.x,pos.y,32,32,`rgb(${c},${c},${c})`);
    c = optionsHover + 69;
    let cc = `rgb(${c},${c},${c})`;
    rect(pos.x,pos.y-6,26,4,cc);
        rect(pos.x-6,pos.y-6,4,8,cc);
    rect(pos.x,pos.y+6,26,4,cc);
        rect(pos.x+11,pos.y+6,4,8,cc);
    //pause
    pos.x-=33;
    rect(pos.x,pos.y,34,34,"#9c9c9c");
    c = pauseHover+45;
    rect(pos.x,pos.y,32,32,`rgb(${c},${c},${c})`);
    c = pauseHover + 69;
    cc = `rgb(${c},${c},${c})`;
    if(paused) {
        shape(pos.x,pos.y,[{x:-7,y:-10},{x:-7,y:10},{x:10,y:0}],cc);
    } else {
        rect(pos.x+6,pos.y,6,20,cc);
        rect(pos.x-6,pos.y,6,20,cc);
    }
}

function drawOptionsMenu() {
    if(optionsMenu) {
        let pos = {x:cw/2-100,y:ch/2-100};
        rect(cw/2,ch/2,200,200,"#242424");
        text("Screen Size:",pos.x+2,pos.y+2,"white",2);
            let b = optionsButtons.screenSize;
            rect(b.x,b.y,b.w,b.h,"#444444");
            text(screenSize,pos.x+145,pos.y+4,"white",2);
        text("sfx",pos.x+2,pos.y+30,"white",2);
            b = optionsButtons.sfx;
            rect(b.x,b.y,b.w,b.h-10,"#444444");
            rect((b.x-60)+(volume.sfx*120),b.y,8,20,"#444444");
        text("bmg",pos.x+2,pos.y+60,"white",2);
            b = optionsButtons.bmg;
            rect(b.x,b.y,b.w,b.h-10,"#444444");
            rect((b.x-60)+(volume.bgm*120),b.y,8,20,"#444444");
    }
}
var k={a:65,b:66,c:67,d:68,e:69,f:70,g:71,h:72,i:73,j:74,k:75,l:76,m:77,n:78,o:79,p:80,q:81,r:82,s:83,t:84,u:85,v:86,w:87,x:88,y:89,z:90,0:48,1:49,2:50,3:51,4:52,5:53,6:54,7:55,8:56,9:57,BACKTICK:192,MINUS:189,EQUALS:187,OPENSQUARE:219,ENDSQUARE:221,SEMICOLON:186,SINGLEQUOTE:222,BACKSLASH:220,COMMA:188,PERIOD:190,SLASH:191,ENTER:13,BACKSPACE:8,TAB:9,CAPSLOCK:20,SHIFT:16,CONTROL:17,ALT:18,META:91,LEFTBACKSLASH:226,ESCAPE:27,HOME:36,END:35,PAGEUP:33,PAGEDOWN:34,DELETE:46,INSERT:45,PAUSE:19,UP:38,DOWN:40,LEFT:37,RIGHT:39,CONTEXT:93,SPACE:32,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123};
var keyPress = [];
var keyDown = [];
var mousePress = [];
var mouseDown = [];
var scroll = 0;
var mousePos = {
    x:0,
    y:0
}
var preventedEvents = [false,true,true];

function addListenersTo(elementToListenTo) {
    window.addEventListener("keydown",kdown);
    window.addEventListener("keyup",kup);
    elementToListenTo.addEventListener("mousedown",mdown);
    elementToListenTo.addEventListener("mouseup",mup);
    elementToListenTo.addEventListener("mousemove",mmove);
    elementToListenTo.addEventListener("contextmenu",cmenu);
    elementToListenTo.addEventListener("wheel",scrl);
}
function removeListenersFrom(elementToListenTo) {
    window.removeEventListener("keydown",kdown);
    window.removeEventListener("keyup",kup);
    elementToListenTo.removeEventListener("mousedown",mdown);
    elementToListenTo.removeEventListener("mouseup",mup);
    elementToListenTo.removeEventListener("mousemove",mmove);
    elementToListenTo.removeEventListener("contextmenu",cmenu);
    elementToListenTo.removeEventListener("wheel",scrl);
}
function resetInput() {
    for(var i=0;i<keyPress.length;i++){if(keyPress[i]){keyPress[i]=0}}
    for(var i=0;i<mousePress.length;i++){if(mousePress[i]){mousePress[i]=0}}
    scroll=0;
}
function kdown(e) {
    var h=e.keyCode;
    keyPress[h]=keyPress[h]==[][[]]?1:0;
    keyDown[h]=1;
    if(preventedEvents[0]) {e.preventDefault()}
}
function kup(e) {
    var h=e.keyCode;
    delete keyPress[h];
    delete keyDown[h];
}
function mdown(e) {
    var h=e.button;
    mousePress[h]=mousePress[h]==[][[]]?1:0;
    mouseDown[h]=1;
    if(preventedEvents[1]) {e.preventDefault()}
}
function mup(e) {
    var h=e.button;
    delete mousePress[h];
    delete mouseDown[h];
}
function mmove(e) {
    mousePos.x=e.offsetX/(!canvasScale?autoScale:canvasScale);
    mousePos.y=e.offsetY/(!canvasScale?autoScale:canvasScale);    
}
function cmenu(e) {
    if(preventedEvents[1]) {e.preventDefault()}
}
function scrl(e) {
    scroll+=-1*(e.deltaY/100);
    if(preventedEvents[2]) {e.preventDefault()}
}
function dist(point1,point2) {
    let one = (point2.x - point1.x);
    let two = (point2.y - point1.y);
    return Math.sqrt((one*one)+(two*two));
}

function circlecircle(circle1,circle2) {
    if( dist(circle1,circle2) < (circle1.r + circle2.r)) {
		return true;
	} else {
        return false;
    }
}

function circlepoint(circle,point) {
    if( dist(circle,point) < circle.r) {
		return true;
	} else {
        return false;
    }
}

function rectrect(rect1,rect2) {
    if(rect1.x + rect1.w/2 >= rect2.x - rect2.w/2 &&
       rect1.x - rect1.w/2 <= rect2.x + rect2.w/2 &&
       rect1.y + rect1.h/2 >= rect2.y - rect2.h/2 &&
       rect1.y - rect1.h/2 <= rect2.y + rect2.h/2) {
        return true;
    } else {
        return false;
    }
}

function rectpoint(rect,point) {
    if(rect.x + rect.w/2 >= point.x &&
       rect.x - rect.w/2 <= point.x &&
       rect.y + rect.h/2 >= point.y &&
       rect.y - rect.h/2 <= point.y ) {
        return true;
    } else {
        return false;
    }
}

function circlerect(circle,rect) { //credit: https://yal.cc/rectangle-circle-intersection-test/
    let rectHalfWidth  = rect.w/2;
    let rectHalfHeight = rect.h/2;
    let deltaX = circle.x - Math.max(rect.x - rectHalfWidth, Math.min(circle.x, rect.x + rectHalfWidth));
    let deltaY = circle.y - Math.max(rect.y - rectHalfHeight, Math.min(circle.y, rect.y + rectHalfHeight));
    return (deltaX * deltaX + deltaY * deltaY) < (circle.r * circle.r);
}

function circleOnSideRect(circle,rect) {
    let rectHalfWidth  = rect.w/2;
    let rectHalfHeight = rect.h/2;
    let left   = rect.x - rectHalfWidth;
    let right  = rect.x + rectHalfWidth;
    let top    = rect.y - rectHalfHeight;
    let bottom = rect.y + rectHalfHeight;
    let cx = circle.x;
    let cy = circle.y;
    if(cy < top && cx > left && cx < right) { // top side
        return 0;
    } else if(cy > bottom && cx > left && cx < right) { // bottom side
        return 2;
    } else if (cx < left && cy > top && cy < bottom) { // left side
        return 3;
    } else if (cx > right && cy > top && cy < bottom) { // right side
        return 1;
    } else {
        let returnValue=0; // 0 = top, 1 = right, 2 = bottom, 3 = left
        let topleft = dist (circle,{x:left,y:top});
        let topright = dist (circle,{x:right,y:top});
        let bottomleft = dist (circle,{x:left,y:bottom});
        let bottomright = dist (circle,{x:right,y:bottom});
        switch(Math.min(topleft,topright,bottomleft,bottomright)) { // find what corner the cricle is closer to, then determine what side it is closer to
            case topleft:
                var m = slope(rect,{x:left,y:top});
                var mperp = -(1/m);
                var b = yIntercept(rect,m);
                var bperp = yIntercept(circle,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 3;} else {returnValue = 0;}
                break;
            case topright:
                var m = slope(rect,{x:right,y:top});
                var mperp = -(1/m);
                var b = yIntercept(rect,m);
                var bperp = yIntercept(circle,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 0;} else {returnValue = 1;}
                break;
            case bottomleft:
                var m = slope(rect,{x:left,y:bottom});
                var mperp = -(1/m);
                var b = yIntercept(rect,m);
                var bperp = yIntercept(circle,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 3;} else {returnValue = 2;}
                break;
            case bottomright:
                var m = slope(rect,{x:right,y:bottom});
                var mperp = -(1/m);
                var b = yIntercept(rect,m);
                var bperp = yIntercept(circle,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 2;} else {returnValue = 1;}
                break;
        }
        return returnValue;
    }
}

function rectOnSideRect(rect1,rect2) {
    let rectHalfWidth2  = rect2.w/2;
    let rectHalfHeight2 = rect2.h/2;
    let left2   = rect2.x - rectHalfWidth2;
    let right2 = rect2.x + rectHalfWidth2;
    let top2   = rect2.y - rectHalfHeight2;
    let bottom2 = rect2.y + rectHalfHeight2;

    let rectHalfWidth1  = rect1.w/2;
    let rectHalfHeight1 = rect1.h/2;
    let rx1 = rect1.x;
    let ry1 = rect1.y;
    let left1   = rx1 - rectHalfWidth1;
    let right1 = rx1 + rectHalfWidth1;
    let top1   = ry1 - rectHalfHeight1;
    let bottom1 = ry1 + rectHalfHeight1;
    // find what point is closer to the rectangle 
    let topleft1 = dist (rect2,{x:left1,y:top1});
    let topright1 = dist (rect2,{x:right1,y:top1});
    let bottomleft1 = dist (rect2,{x:left1,y:bottom1});
    let bottomright1 = dist (rect2,{x:right1,y:bottom1});
    let topmiddle1 = dist (rect2,{x:rx1,y:top1});
    let rightmiddle1 = dist (rect2,{x:right1,y:ry1});
    let bottommiddle1 = dist (rect2,{x:rx1,y:bottom1});
    let leftmiddle1 = dist (rect2,{x:left1,y:ry1});
    let cx = rx1;
    let cy = ry1;
    switch(Math.min(topleft1,topright1,bottomleft1,bottomright1,topmiddle1,rightmiddle1,bottommiddle1,leftmiddle1)) {
        //set the point we are testing to the closest point to the rectangle
        case topleft1:
            cx -= rect1.w/2;
            cy -= rect1.h/2;
            break;
        case topright1:
            cx += rect1.w/2;
            cy -= rect1.h/2;
            break;
        case bottomleft1:
            cx -= rect1.w/2;
            cy += rect1.h/2;
            break;
        case bottomright1:
            cx += rect1.w/2;
            cy += rect1.h/2;
            break;
        case topmiddle1:
            cy -= rect1.h/2;
            break;
        case rightmiddle1:
            cx += rect1.w/2;
            break;
        case bottommiddle1:
            cy += rect1.h/2;
            break;
        case leftmiddle1:
            cx -= rect1.w/2;
            break;
    }
    if(cy < top2 && cx > left2 && cx < right2) { // top side
        return 0;
    } else if(cy > bottom2 && cx > left2 && cx < right2) { // bottom side
        return 2;
    } else if (cx < left2 && cy > top2 && cy < bottom2) { // left side
        return 3;
    } else if (cx > right2 && cy > top2 && cy < bottom2) { // right side
        return 1;
    } else {
        let returnValue=0; // 0 = top, 1 = right, 2 = bottom, 3 = left
        let determiningPoint = {x:cx,y:cy};
        let topleft = dist (determiningPoint,{x:left2,y:top2});
        let topright = dist (determiningPoint,{x:right2,y:top2});
        let bottomleft = dist (determiningPoint,{x:left2,y:bottom2});
        let bottomright = dist (determiningPoint,{x:right2,y:bottom2});
        switch(Math.min(topleft,topright,bottomleft,bottomright)) { // find what corner the point is closer to, then determine what side it is closer to
            case topleft:
                var m = slope(rect2,{x:left2,y:top2});
                var mperp = -(1/m);
                var b = yIntercept(rect2,m);
                var bperp = yIntercept(determiningPoint,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 3;} else {returnValue = 0;}
                break;
            case topright:
                var m = slope(rect2,{x:right2,y:top2});
                var mperp = -(1/m);
                var b = yIntercept(rect2,m);
                var bperp = yIntercept(determiningPoint,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 0;} else {returnValue = 1;}
                break;
            case bottomleft:
                var m = slope(rect2,{x:left2,y:bottom2});
                var mperp = -(1/m);
                var b = yIntercept(rect2,m);
                var bperp = yIntercept(determiningPoint,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 3;} else {returnValue = 2;}
                break;
            case bottomright:
                var m = slope(rect2,{x:right2,y:bottom2});
                var mperp = -(1/m);
                var b = yIntercept(rect2,m);
                var bperp = yIntercept(determiningPoint,mperp);
                var mid = POI(m,b,mperp,bperp);
                if(cx<mid) {returnValue = 2;} else {returnValue = 1;}
                break;
        }
        return returnValue;
    }
}

function slope(point1,point2) {
    return ((point2.y-point1.y)/(point2.x-point1.x));
}

function yIntercept(point,slope) {
    return point.y - (slope * point.x);
}

function POI(m1,b1,m2,b2) {
    x = (b2 - b1) / (m1 - m2);
    return x;
    //y = m1 * x + b1;
}

function ifRectOnEdgeBounce(rect) {
    let rx = rect.x;
    let ry = rect.y;
    let rw = rect.w/2;
    let rh = rect.h/2;
    if(rx+rw>edge.right) {
        rect.v.x *= -1;
        rect.x = edge.right-rw;
    }
    if(rx-rw<edge.left) {
        rect.v.x *= -1;
        rect.x = edge.left+rw;
    }
    if(ry+rh>edge.bottom) {
        rect.v.y *= -1;
        rect.y = edge.bottom-rh;
    }
    if(ry-rh<edge.top) {
        rect.v.y *= -1;
        rect.y = edge.top+rh;
    }
}

function ifCircleOnEdgeBounce(circle) {
    let cx = circle.x;
    let cy = circle.y;
    let cr = circle.r;
    if(cx+cr>edge.right) {
        circle.v.x *= -1;
        circle.x = edge.right-cr;
    }
    if(cx-cr<edge.left) {
        circle.v.x *= -1;
        circle.x = edge.left+cr;
    }
    if(cy+cr>edge.bottom) {
        circle.v.y *= -1;
        circle.y = edge.bottom-cr;
    }
    if(cy-cr<edge.top) {
        circle.v.y *= -1;
        circle.y = edge.top+cr;
    }
}
// create globals
var canvases={cvs:null,ctx:null,buffer1cvs:null,buffer1ctx:null,buffer2cvs:null,buffer2ctx:null}, // visable and hidden canvases
cw, // canvas width
ch, // canvas height
camera={zoom:1,angle:0,x:0,y:0}, // affects how everything is drawn
updateFPS=60,
gameStarted=false,
drawMode=0, // 0=normal, 1=zoomed, 2=zoomed/rotated, set automatically depending on camera
absDraw=false,
curCtx, // what canvas to draw to
maxCvsSize, // used by second buffer
canvasScale=1,
difx=0, // offsets for drawing
dify=0,
seperateInputLoop=true,
edge={top:null,bottom:null,left:null,right:null}, // used by if___OnEdgeBounce, set to canvas size at setup, can be changed whenever
drawLimitLeft,
drawLimitRight,
drawLimitTop,
drawLimitBottom,
sizeDif,
bug="\uD83D\uDC1B",
loadingCircle,
loadAng=0,
optionsHover=0,
pauseHover=0,
optionsMenu=false,
optionsButtons={},
clickSound,
paused=false,
screenSize="1:1",
autoScale=1,

images=[], // put image paths here
imagePaths=[],
imgs=[],
sprites={}, // loaded images

audio=[], // put audio paths here
audioPaths=[],
sounds={}, // loaded sounds
abuffer = [], // audio nodes shoved here
volumeList = [], // gain nodes shoved here
audioLoadedLength=0,
volume={sfx:1,bgm:1};
/* options
    future:
        modefileable checklist
        key bindings
*/

cursor = {sprite:null,alignment:1,show:true}, // 0=topleft, 1=centered
mouseOnCanvas=false;

const acceptableChars="qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890_-. ";//for image names

const AudioContext = window.AudioContext||window.webkitAudioContext;
var context;
var sfxVolumeNode;
var bmgVolumeNode;

document.getElementById("game").onmouseout = function()   {mouseOnCanvas = false;}
document.getElementById("game").onmouseover = function()   {mouseOnCanvas = true;}

//setup canvases and input
function setup(physicsFPS) {
    updateFPS = physicsFPS;
    
    canvases.cvs = document.getElementById("game");
    canvases.ctx = canvases.cvs.getContext("2d", { alpha: false });

    canvases.cvs.onmousedown = function () {if(!gameStarted){loadImagesAndSounds();gameStarted=true;}}

    createCanvas("buffer1");
    createCanvas("buffer2");

    canvases.ctx.imageSmoothingEnabled = false;
    canvases.buffer1ctx.imageSmoothingEnabled = false;
    canvases.buffer2ctx.imageSmoothingEnabled = false;

    maxCvsSize=Math.max(canvases.cvs.width,canvases.cvs.height);
    sizeDif=maxCvsSize-Math.min(canvases.cvs.width,canvases.cvs.height);
    cw=canvases.cvs.width;
    ch=canvases.cvs.height;
    
    edge={top:0,bottom:ch,left:0,right:cw};

    addFont();
    addStyle();

    addListenersTo(canvases.cvs);

    curCtx = canvases.ctx;
    requestAnimationFrame(startButton);
    function startButton() {
        curCtx.fillStyle="#2d2d2d";
        curCtx.fillRect(0,0,cw,ch);//debugger;
        circle(cw/2,ch/2,27,"#066312");
        circle(cw/2,ch/2,23,"#149124");
        shape(cw/2,ch/2,[{x:-7,y:-15},{x:-7,y:15},{x:15,y:0}],"#47f55d");
        if(!gameStarted) {requestAnimationFrame(startButton);}
    }
}

function drawLoop() {
    cw=canvases.cvs.width;
    ch=canvases.cvs.height;
    scaleCanvases();

    switchDrawMode();
    
    resizeBuffers();

    clearCanvases();

    var limitModifyer = 0;
    if(drawMode==2) {limitModifyer=canvases.buffer2cvs.width-maxCvsSize;}
    drawLimitLeft   = -camera.x - (drawMode==2?sizeDif:0) - limitModifyer;
    drawLimitRight  = -camera.x + maxCvsSize + (drawMode==2?sizeDif:0) + limitModifyer;
    drawLimitTop    = -camera.y -(drawMode==2?sizeDif:0) - limitModifyer;
    drawLimitBottom = -camera.y + maxCvsSize + (drawMode==2?sizeDif:0) + limitModifyer;

    draw();
    
    render();

    curCtx=canvases.ctx;
    difx=0;dify=0;
    var camCache = {x:camera.x,y:camera.y};
    var drawModeCache = drawMode;
    camera.x=0;camera.y=0;
    drawMode=0;
    absDraw=true;
    try{absoluteDraw();} catch (err){}
    absDraw=false;

    drawButtons();
    drawOptionsMenu();
    drawCursor();

    drawMode=drawModeCache;

    camera.x = camCache.x;
    camera.y = camCache.y;

    requestAnimationFrame(drawLoop);
}

function updateLoop() {
    if(seperateInputLoop==false) {
        handleOptionsInput();
    }
    sfxVolumeNode.gain.value = volume.sfx;
    bmgVolumeNode.gain.value = volume.bgm;
    if(!paused) {
        update();
    }

    if(seperateInputLoop==false) {
        resetInput();
    }
}


function inputLoop() {
    handleOptionsInput();
    if(!paused) {
        input();
    }

    resetInput();
}
class Enemy {
    constructor(x,y,w,h,range,loadout,id) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.range = range;
        this.loadout = loadout;
        this.id = id;
        
        this.selAttack;

        this.hovered = false;
    }
}

Enemy.prototype.draw = function() {
    // selection circle
    if(curBattleState === bStates.pSelect) {
        var pulse = Math.abs(15-(updateCount%30))/4;
        pulse = this.hovered ? 7 : pulse;
        circle(this.x,this.y,Math.max(this.w,this.h)/2 + pulse,"#99999955");
    }
    // rect(this.x,this.y,this.w,this.h,"blue");
    img(sprites.tempEnemy,this.x,this.y);
}

Enemy.prototype.baseUpdate = function(index) {
    // battle
    if(globalState === states.battle) {
        if(curBattleState === bStates.pSelect) {
            // hovering over enemy
            if(rectpoint(this,mousePosition())) {
                this.hovered = true;
            } else {
                this.hovered = false;
            }
            if(this.hovered && mousePress[0]) {
                setTarget(index);
            }
        }
    // world
    } else {

        if(dist(this,player) < this.range) {
            //move towards player
        }

        if(rectrect(this,player)) {
            //initiate battle
            let enemyXPos = 400;
            fightId = this.id;
            for(let i = 0;i < this.loadout.length;i++) {
                fightEnemies.push(enemyDefinitions[this.loadout[i]](enemyXPos,300,i));
                enemyXPos += 50;
            }
            globalState = states.battle;
        }
    }
}

Enemy.prototype.worldUpdate = function(){};
Enemy.prototype.fightUpdate = function(){};

Enemy.prototype.move = function(x,y) {
    this.x = x;
    this.y = y;
}

Enemy.prototype.checkDead = function() {
    if(this.hp <= 0) {
        income += rand(this.value - (this.value / 2),this.value + (this.value / 2));
        fightEnemies.splice(this.id,1);

        for(let i = 0;i < fightEnemies.length;i++) {
            if(fightEnemies[i].id > this.id) {
                fightEnemies[i].id--;
            }
        }

        if(fightEnemies.length == 0) {
            winBattle();
        }
    }
}

function drawEnemies() {
    switch(globalState) {
        case states.world:
            for(let i=0;i<worldEnemies.length;i++) {
                worldEnemies[i].draw();
            }
        break;

        case states.battle:
            for(let i=0;i<fightEnemies.length;i++) {
                fightEnemies[i].draw();
            }
        break;
    }
}

function updateEnemies() {
    for(let i=0;i<worldEnemies.length;i++) {
        worldEnemies[i].baseUpdate(i);
        worldEnemies[i].worldUpdate();
    }
}

function updateFightEnemies() {
    for(let i=0;i<fightEnemies.length;i++) {
        fightEnemies[i].baseUpdate(i);
        fightEnemies[i].fightUpdate();
    }
}



class BasicEnemy extends Enemy {
    constructor(x,y,id) {
        super(x,y,24,24,0,0,id);

        this.defaultX = x;
        this.defaultY = y;

        this.hp = 5;
        this.atk = 2;
        this.def = 0;
        this.attacks = [0];
        this.value = 3; 
    }
}
var enemyDefinitions = [
    //0 - basic enemy
    function(x,y,id) {return new BasicEnemy(x,y,id)}
]


class NPC {
    
}
var player;

var income = 0;

class Player {

    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 10;
        this.h = 10;
        this.angle = 0;
        this.vel = 0;
        this.accel = 0.1;
        this.friction = 0.3;
        this.maxVel = 1.5;
        this.cameraTarget = { x: x, y: y };
        
        this.trueStatsMax = {
            hp:20,
            mp:5
        };
        
        this.statsMax = {
            hp:this.trueStatsMax.hp,
            mp:this.trueStatsMax.mp
        };
        
        this.trueStats = {
            hp:20,
            mp:5,
            atk:3,
            int:1,
            def:1
        };

        this.stats = {
            atk:this.trueStats.atk,
            int:this.trueStats.int,
            def:this.trueStats.def
        };

        
        this.money = 100;
        this.xp = 0;

        this.inventory = [];
        this.specialInventory = [];
    }

    draw() {
        img(sprites.tempPlayer, this.x, this.y, -this.angle - pi);
    }

    update() {
        // inventory toggle
        if(keyPress[k.e]) {
            inventory.mainComponent.show = !inventory.mainComponent.show; 
        }

        // movement
        var wasInput = false;
        var angle = 0;
        var divisor = 0;
        // up
        if (keyDown[k.w]) {
            this.vel += this.accel;
            angle -= Math.PI * (keyDown[k.d] ? -1 : 1);
            wasInput = true;
            divisor++;
        }
        // down
        if (keyDown[k.s]) {
            this.vel += this.accel;
            wasInput = true;
            divisor++;
        }
        // left
        if (keyDown[k.a]) {
            this.vel += this.accel;
            wasInput = true;
            angle -= Math.PI / 2;
            divisor++;
        }
        // right
        if (keyDown[k.d]) {
            this.vel += this.accel;
            wasInput = true;
            angle += Math.PI / 2;
            divisor++;
        }
        // determine angle
        divisor = divisor === 0 ? 1 : divisor;
        angle /= divisor;

        // turn towards target angle
        if (wasInput) {
            this.angle = turn(this.angle, angle, 0.175);
        }

        // limit speed
        this.vel = clamp(this.vel, 0, this.maxVel);

        // friction
        if (!wasInput) {
            this.vel = friction(this.vel, this.friction);
        }

        // move x
        var cols = getColliisons(this);
        this.x += Math.sin(this.angle) * this.vel;
        if (colliding(this, cols)) {
            this.x -= Math.sin(this.angle) * this.vel;
        }
        // move y
        this.y += Math.cos(this.angle) * this.vel;
        if (colliding(this, cols)) {
            this.y -= Math.cos(this.angle) * this.vel;
        }

        // camera movement
        var cameraTargetPosition = { x: this.x, y: this.y };
        // if room smaller than screne, set camera to center
        if (roomInfo.width <= 25 && roomInfo.height <= 19) {
            cameraTargetPosition.x = roomInfo.width * 8 - 8;
            cameraTargetPosition.y = roomInfo.height * 8 - 8;
        // else limit camera from going off screen
        } else {
            if (cameraTargetPosition.x < cw / 2 / camera.zoom) { cameraTargetPosition.x = cw / 2 / camera.zoom; }
            if (cameraTargetPosition.y < ch / 2 / camera.zoom) { cameraTargetPosition.y = ch / 2 / camera.zoom; }
            if (cameraTargetPosition.x > roomInfo.width * 16 - cw / 2 / camera.zoom - 8) { cameraTargetPosition.x = roomInfo.width * 16 - cw / 2 / camera.zoom - 8; }
            if (cameraTargetPosition.y > roomInfo.height * 16 - ch / 2 / camera.zoom - 8) { cameraTargetPosition.y = roomInfo.height * 16 - ch / 2 / camera.zoom - 8; }
        }

        // move camera towards player
        this.cameraTarget.x = lerp(this.cameraTarget.x, cameraTargetPosition.x, 0.1);
        this.cameraTarget.y = lerp(this.cameraTarget.y, cameraTargetPosition.y, 0.1);
        centerCameraOn(this.cameraTarget.x, this.cameraTarget.y);
    }

    setCamera() {
        var cameraTargetPosition = { x: this.x, y: this.y };
        // if room smaller than screne, set camera to center
        if (roomInfo.width <= 25 && roomInfo.height <= 19) {
            cameraTargetPosition.x = roomInfo.width * 8 - 8;
            cameraTargetPosition.y = roomInfo.height * 8 - 8;
        // else limit camera from going off screen
        } else {
            if (cameraTargetPosition.x < cw / 2 / camera.zoom) { cameraTargetPosition.x = cw / 2 / camera.zoom; }
            if (cameraTargetPosition.y < ch / 2 / camera.zoom) { cameraTargetPosition.y = ch / 2 / camera.zoom; }
            if (cameraTargetPosition.x > roomInfo.width * 16 - cw / 2 / camera.zoom - 8) { cameraTargetPosition.x = roomInfo.width * 16 - cw / 2 / camera.zoom - 8; }
            if (cameraTargetPosition.y > roomInfo.height * 16 - ch / 2 / camera.zoom - 8) { cameraTargetPosition.y = roomInfo.height * 16 - ch / 2 / camera.zoom - 8; }
        }
        this.cameraTarget.x = cameraTargetPosition.x;
        this.cameraTarget.y = cameraTargetPosition.y;
        centerCameraOn(cameraTargetPosition.x, cameraTargetPosition.y);
    }

    move(x,y) {
        this.x = x;
        this.y = y;
    }
}

player = new Player(0, 0);

const eAttacks = {
    basic:0,
}

function eBasicAttack(enemy) {
    fightEnemies[enemy].x -= 5;
    if(rectrect(player,fightEnemies[enemy])) {
        player.trueStats.hp -= fightEnemies[enemy].atk - player.stats.def; 
        fightEnemies[enemy].move(fightEnemies[enemy].defaultX,fightEnemies[enemy].defaultY);

        curEnemyCheck();
    }   
}





//checks if all enemies have attacked
function curEnemyCheck() {
    if(curEnemy == fightEnemies.length - 1) {
        curEnemy = 0;
        curBattleState = bStates.pTurn;
    } else {
        curEnemy++;
        curBattleState = bStates.eTurn;
    }
}
const attacks = {
    basic:0,
    slash:1
}

const attacksKeys = Object.keys(attacks);


function basicAttack(target) {
    player.x += 5;
    if(rectrect(player,fightEnemies[target])) {
        fightEnemies[target].hp -= player.stats.atk - fightEnemies[target].def;
        fightEnemies[target].checkDead();
        curBattleState = bStates.eTurn;
    }   
}

function slash(target) {
    player.x += 5;
    if(rectrect(player,fightEnemies[target])) {
        fightEnemies[target].hp -= player.stats.atk - fightEnemies[target].def;
        fightEnemies[target].checkDead();
        curBattleState = bStates.eTurn;
    }   
}
class Component {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;

        this.originalX = x;
        this.originalY = y;
        this.relativePosition = false;

        this.parent = null;
        this.children = [];
        // position in parent's children array
        this.position;

        // what parts should be drawn
        this.showBorder = true;
        this.showShadow = true;
        this.showBackground = true;
        this.show = true;

        // colors
        this.backgroundColor = colors.background;
        this.borderColor = colors.border;

        // if children should be able to be focused
        this.ignoreChildUpdate = false;

        // if this shouldn't be moved by parent component
        this.absolutePosition = false;

        // index of when added
        this.idNumber = idCount++;

        // id name set by user
        this.id = "";

        
    }
}
Component.prototype.update = function() {}

Component.prototype.handleFocus = function() {
    if(componentPoint(this,mousePos)) {
        focusedComponent = this.idNumber;
    }
}

// draws overtop base draw
Component.prototype.draw = function() {}

// draw for every component, draws a box
Component.prototype.baseDraw = function() {
    
    if(this.showBackground) {
        if(this.showShadow) {UICtx.toggleShadow(true);}
        UICtx.fillStyle = this.backgroundColor;
        UICtx.fillRect(this.x,this.y,this.w,this.h); 
        if(this.showShadow) {UICtx.toggleShadow(false);}
    }
   
    if(this.showBorder) {
        UICtx.strokeStyle = this.borderColor;
        UICtx.beginPath();
        UICtx.rect(this.x,this.y,this.w,this.h);
        UICtx.stroke();
    }
}

// add child
Component.prototype.addChild = function(component) {
    component.position = this.children.length;
    component.parent = this;
    this.children.push(component);
}

// delete
Component.prototype.delete = function() {
    this.parent.removeChild(this.position);
}

// remove child
Component.prototype.removeChild = function(position) {
    this.children.splice(position,1);
    for(let i=0;i<this.children.length;i++) {
        this.children[i].position = i;
    }
}

// get component
function getComponentById(id) {
    for(let i=0;i<components.length;i++) {
        if(components[i].id === id) {
            return components[i];
        }
        let comp = searchForComponent(components[i],id);
        if(comp !== null) {
            return comp;
        }
    }
    return null;
}
function searchForComponent(component,id) {
    for(let i=0;i<component.children.length;i++) {
        if(component.children[i].id === id) {
            return component.children[i];
        }
        let comp = searchForComponent(component.children[i],id);
        if(comp !== null) {
            return comp;
        }
    }
    return null;
}

// draw
function drawComponents() {
    for(var i=0;i<components.length;i++) {
        if(components[i].show) {
            components[i].baseDraw();
            components[i].draw();
            drawChildren(components[i]);
        }
    }
}
function drawChildren(component) {
    for(let i=0;i<component.children.length;i++) {
        if( component.children[i].show) {
            component.children[i].baseDraw();
            component.children[i].draw();
            drawChildren(component.children[i]); 
        }
    }
}

// update
function updateComponents() {
    focusedComponent = null;
    for(var i=0;i<components.length;i++) {
        if(components[i].show) {
            components[i].handleFocus();
            handleFocusChild(components[i]);
        }
    }
    for(var i=0;i<components.length;i++) {
        components[i].update();
        updateChildren(components[i]);
    }
}
function handleFocusChild(component) {
    if(!component.ignoreChildUpdate) {
        for(let i=0;i<component.children.length;i++) {
            if(component.children[i].show) {
                component.children[i].handleFocus();
                handleFocusChild(component.children[i]);
            }
        }
    }
}
function updateChildren(component) {
    for(let i=0;i<component.children.length;i++) {
        component.children[i].update();
        updateChildren(component.children[i]);
    }
}

// rect point collision for ui
function componentPoint(rect,point) {
    if(rect.x + rect.w >= point.x &&
       rect.x <= point.x &&
       rect.y + rect.h >= point.y &&
       rect.y <= point.y ) {
        return true;
    } else {
        return false;
    }
}

class Button extends Component {
    constructor(x, y, onclick) {
        super(x, y, 10, 10);
        this.onclick = onclick;
        this.ignoreChildUpdate = true;
        this.padding = 4;
        this.showBorder = false;
        this.hover = false;
        this.click = false;
    }
}

Button.prototype.draw = function() {
    if (this.click) {
        // shadow top and left
        UIRect(this.x, this.y, this.w, 3, "#0a0a0a");
        UIRect(this.x, this.y, 3, this.h, "#0a0a0a");
    } else {
        // shadow bottom and right
        UIRect(this.x, this.y + this.h - 2, this.w, 3, "#0a0a0a");
        UIRect(this.x + this.w - 3, this.y, 3, this.h, "#0a0a0a");
        // highlight top and left
        UIRect(this.x, this.y, this.w, 3, "#373737");
        UIRect(this.x, this.y, 3, this.h, "#373737");
    }
}

Button.prototype.update = function() {
    this.backgroundColor = colors.background;
    this.hover = false;
    this.click = false;
    // if this is focused, handle clicking
    if (focusedComponent === this.idNumber) {
        // call on click when clicked
        if (mousePress[0]) {
            this.onclick();
        }
        // set color depending on hover and click
        if (mouseDown[0]) {
            this.backgroundColor = colors.click;
            this.click = true;
        } else {
            this.backgroundColor = colors.hover;
            this.hover = true;
        }
    }
    // highest height of all children
    let maxH = 10;
    // width of all children together
    let finalW = this.padding;
    // x and y offset for children depending on if this is held down
    let off = this.click ? 2 : 0;
    // go through all children
    for (let i = 0; i < this.children.length; i++) {
        let c = this.children[i];
        // if this is the highest child set this height to it
        if (c.h > maxH) {
            maxH = c.h;
        }
        // position child
        c.x = finalW + this.x + off;
        c.y = this.y + this.padding + off;
        // increase width
        finalW += c.w + 2;
    }
    // adapt dimensions 
    this.w = finalW + this.padding - 2;
    this.h = maxH + this.padding * 2;
}
class HorizontalLayout extends Component {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        // space between border and elements
        this.padding = 2;
        // space between elements
        this.spacing = 2;
        // if dimensions should change to fit children
        this.adaptWidth = true;
        this.adaptHeight = true;
    }
}

HorizontalLayout.prototype.update = function() {
    // highest height of all children
    let maxH = 10;
    // width of all children together
    let finalW = this.padding;
    // go through all children
    for (let i = 0; i < this.children.length; i++) {
        let c = this.children[i];
        // if child should be moved
        if(!c.absolutePosition) {
            // if this is the highest child set this height to it
            if (c.h > maxH) {
                maxH = c.h;
            }
            // position child
            if(c.relativePosition) {
                c.x = finalW + this.x + c.originalX;
                c.y = this.y + this.padding + c.originalY;
                finalH += c.originalX;
            } else {
                c.x = finalW + this.x;
                c.y = this.y + this.padding;
            }
            // increase width
            finalW += c.w + this.spacing;
        }
    }
    // adapt dimensions if this should
    if (this.adaptWidth) { this.w = finalW + this.padding - 2; }
    if (this.adaptHeight) { this.h = maxH + this.padding * 2; }
}
class ImageComponent extends Component {
    constructor(x, y, sprite, scale = 1) {
        super(x, y, sprite.spr.width * scale, sprite.spr.height * scale);
        this.image = sprite.spr;
        this.scale = scale;
        this.showBorder = false;
    }
}

ImageComponent.prototype.draw = function() {
    if(this.scale !== 1) {
        UIImageScaled(this.image, this.x, this.y, this.scale);
    } else {
        UIImage(this.image, this.x, this.y);
    }
}
class TextComponent extends Component {
    constructor(x, y, w, color,size, functionThatReturnsString = function () { return "default text"; }) {
        super(x, y, w, 8*size);
        this.txtFunc = functionThatReturnsString;
        this.color = color;
        this.size = size;
        this.string = "";
        this.showShadow = false;
        this.showBorder = false;
        this.showBackground = false;
    }
}

TextComponent.prototype.update = function() {
    // get the string from the function passed into constructor that returns a string
    this.string = this.txtFunc();
}

TextComponent.prototype.draw = function() {
    // draw text, and adapt height to accommodate text wrapping
    this.h = UIText(this.string,this.x,this.y,this.color,this.size,this.w);
}

// if you want to type less to make a text component that has a constant string
function returnStr(str) {
    return function(){return str;};
}
class VerticalLayout extends Component {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        // space between border and elements
        this.padding = 2;
        // space between elements
        this.spacing = 2;
        // if dimensions should change to fit children
        this.adaptWidth = true;
        this.adaptHeight = true;
    }
}

VerticalLayout.prototype.update = function() {
    // widest width of all children 
    let maxW = 10;
    // height of all children together
    let finalH = this.padding;
    // go through all children
    for (let i = 0; i < this.children.length; i++) {
        let c = this.children[i];
        // if child should be moved
        if(!c.absolutePosition) {
            // if this is the widest child, set parent width to it
            if (c.w > maxW) {
                maxW = c.w;
            }
            // position child
            if(c.relativePosition) {
                c.y = finalH + this.y + c.originalY;
                c.x = this.x + this.padding + c.originalX;
                finalH += c.originalY;
            } else {
                c.y = finalH + this.y;
                c.x = this.x + this.padding;
            }
            // increase height
            finalH += c.h + this.spacing;
        }
    }
    // adapt dimensions if this should
    if (this.adaptWidth) { this.h = finalH + this.padding - 2; }
    if (this.adaptHeight) { this.w = maxW + this.padding * 2; }
}
function handleTitleScreen(isNewState) {
    
}

function drawTitleScreen() {
    text("RPG game lol example text aaaaaaaaaaaaaaaaa",100,200,"green",4,400);
}
// array of parentless components
var components = [];

// color constants for ui
const colors = {
    border: "#555555",
    background: "#1e1e1e",
    hover:"#333333",
    click:"#111111"
};

// id of focused component
var focusedComponent = null;

// every new ui component gets an id incremented from the last
var idCount = 0;

// canvas for drawing ui
var UICanvas = document.createElement("canvas");
var UICtx = UICanvas.getContext("2d");
UICtx.textAlign = "left";
UICtx.textBaseline = "top";

// add pixel font
document.getElementsByTagName("style")[0].innerHTML += `@font-face {
    font-family: "pixelmix";
    src: url("./scripts/ui/font/pixelmix.ttf") format("truetype");
}`;

UICtx.font = "6px pixelmix";

// add a shadow toggling function to context2d prototype
UICtx.__proto__.toggleShadow = function (boolOn) {
    if (boolOn) {
        this.shadowOffsetY = 5;
        this.shadowColor = "#000000bb";
        this.shadowBlur = 5;
    } else {
        this.shadowOffsetY = 0;
        this.shadowColor = "#00000000";
        this.shadowBlur = 0;
    }
}

function drawUI() {
    // resize
    UICanvas.width = canvases.cvs.width;
    UICanvas.height = canvases.cvs.height;

    UICtx.imageSmoothingEnabled = false;
    //clear
    UICtx.clearRect(0, 0, UICanvas.width, UICanvas.height);

    drawComponents();

    // draw to screen
    imgIgnoreCutoff({ spr: UICanvas }, UICanvas.width / 2, UICanvas.height / 2, 0, 1, 1);
}

function makeStatsUI() {
    // top bar
    var bar = new HorizontalLayout(0,0,cw,75);
    // hp
    bar.addChild(new TextComponent(0,6,100,"#ba5956",2,function(){return `hp: ${player.trueStats.hp}`;}));
    bar.addChild(new TextComponent(0,22,100,"#e3d449",2,function(){return `$ ${player.money}`;}));
    bar.addChild(new TextComponent(0,40,100,"#63e693",2,function(){return `XP: ${player.xp}`;}));
    bar.id = "statsBar";
    bar.adaptWidth = false;
    bar.adaptHeight = false;
    bar.showShadow = false;
    bar.backgroundColor = colors.background + "cc";
    components.push(bar);
}

// rectangle
function UIRect(x, y, w, h, c) {
    UICtx.fillStyle = c;
    UICtx.fillRect(x, y, w, h);
}

// rectangle border
function UIBorder(x, y, w, h, c) {
    UICtx.strokeStyle = c;
    UICtx.beginPath();
    UICtx.rect(x, y, w, h);
    UICtx.stroke();
}

// image
function UIImage(img,x,y) {
   UICtx.drawImage(img,x,y);
}
function UIImageScaled(img,x,y,scale) {
    UICtx.drawImage(img,0,0,img.width,img.height,x,y,scale*img.width,scale*img.height);
}

// draw text
function UIText(txt,x,y,color="white",size=1,maxWidth=cw) {
    txt = txt.toString();
    UICtx.fillStyle = color;
    UICtx.font = `${Math.round(size)*8}px pixelmix`;
                                                                                        //I hate text wrapping now 
    var txtList = txt.split("\n");                                                      //split string on enters
    for(let i=0;i<txtList.length;i++) {                                                 //go through array of strings
        if(UICtx.measureText(txtList[i]).width>maxWidth) {                              //if the string is too big, divide up into smaller strings
            var tempTxt = txtList[i].split(" ");                                        //split into individual words
            var tempStr="";                                                             //string for measuring size
            var addAmount=0;                                                            //track where in the txtList we are
            txtList.splice(i,1);                                                        //remove the too long string
            for(let j=0;j<tempTxt.length;j++) {                                         //go through the split up string
                if(UICtx.measureText(tempStr + tempTxt[j] + " ").width<maxWidth) {      //if adding a word doesn't make tempStr too long, add it, other wise, add tempStr to txtList;
                    tempStr += tempTxt[j] + " ";
                } else {
                    if(j==0) {tempStr+=tempTxt[j];}                                     //if we are here when j is 0, we have one word that is longer then the maxWidth, so we just draw it
                    txtList.splice(i+addAmount,0,tempStr);                              //put tempStr in txtList
                    addAmount++;                                                        //move the position we put the tempStr in
                    tempStr="";                                                         //reset tempStr
                    tempTxt.splice(0,(j==0?1:j));                                       //delete words that have been used
                    j=-1;                                                               //make it so in the next loop, j starts at 0
                }
            }
            if(tempStr.length!=0) {
                txtList.splice(i+addAmount,0,tempStr);                                  //add any leftover text
            }
        }
    }

    for(let i=0;i<txtList.length;i++) {
        UICtx.fillText(txtList[i],x,y+((i+1)*8*size+(size*i)));
    }

    return txtList.length*8*size + size*txtList.length;
}
var battleUI = {};

function toggleBattleUI(shouldShow) {
    battleUI.div.show = shouldShow;
}

function makeBattleUI() {
    // invisible div to make hiding/showing easier
    battleUI.div = new Component(0,0,0,0);

    
    

    // bottom bar
    battleUI.mainBar = new HorizontalLayout(0,ch-100,cw,100);
    battleUI.mainBar.adaptWidth = false;
    battleUI.mainBar.adaptHeight = false;

        // attack button
        var attackAction = new Button(0,ch-75,function(){battleUI.attackSelect.show = !battleUI.attackSelect.show;});
        attackAction.addChild(new TextComponent(0,0,75,"#ba302b",2,returnStr("Attack")));
        battleUI.mainBar.addChild(attackAction);

        // attack select
        battleUI.attackSelect = new VerticalLayout(5,ch-400,200,300);
        battleUI.attackSelect.adaptWidth = false;
        battleUI.attackSelect.adaptHeight = false;
        battleUI.attackSelect.absolutePosition = true;
        battleUI.attackSelect.show = false;
        battleUI.attackSelect.id = "attackSelect";
        battleUI.mainBar.addChild(battleUI.attackSelect);
        

            // basic attack
            var basicAttack = new Button(0,0,function(){
                curAttack = attacks.basic;
                curBattleState = bStates.pSelect;
            });
            basicAttack.addChild(new TextComponent(0,0,100,"white",1,returnStr("Punch")));
            basicAttack.id = attacksKeys[attacks.basic];
            battleUI.attackSelect.addChild(basicAttack);

            //slash
            var slash = new Button(0,30,function(){
                curAttack = attacks.slash;
                curBattleState = bStates.pSelect;
            });
            slash.addChild(new TextComponent(0,0,100,"white",1,returnStr("Slash")));
            slash.id = attacksKeys[attacks.slash];
            battleUI.attackSelect.addChild(slash);
            

    battleUI.div.addChild(battleUI.mainBar);
    
    // select enemy message
    battleUI.pSelect = new TextComponent(50,ch-50,300,"white",2,returnStr("Select an enemy to Attack"));
    battleUI.pSelect.showShadow = true;
    battleUI.pSelect.backgroundColor = colors.background;
    battleUI.div.addChild(battleUI.pSelect);
    
    components.push(battleUI.div);
}
//battle states
const bStates = {
    pTurn:0,
    pSelect:1,
    pAnimate:2,
    eTurn:3,
    eAnimate:4
}

//player's default battle position
const defaultPos = {
    x:275,
    y:300
}

var worldEnemies = [];
var fightEnemies = [];

var fightId;

var curBattleState; 
var lastBattleState;
var curAttack;
var curEnemy = 0;
var target;

function handleBattle(isNewState) {
    if(isNewState) {
        toggleBattleUI(true);
        camera.x = 0;
        camera.y = 0;

        player.move(defaultPos.x,defaultPos.y);

        curBattleState = bStates.pTurn;

        player.angle = pi/2;

        var attackSelect = getComponentById("attackSelect").children;
        for(let i = 0;i < attackSelect.length;i++) {
            attackSelect[i].show = false;
        }
        attackSelect[0].show = true;
        checkEquips();
    }

    updateComponents();
    
    isNewBattleState = false;
    if(curBattleState !== lastBattleState) {
        isNewBattleState = true;
    }
    lastBattleState = curBattleState;


    switch(curBattleState) {
        case bStates.pTurn:
            if(isNewBattleState) {
                battleUI.mainBar.show = true;
                battleUI.pSelect.show = false;
            }
        break;

        case bStates.pSelect:
            if(isNewBattleState) {
                battleUI.mainBar.show = false;
                battleUI.pSelect.show = true;
                battleUI.attackSelect.show = false;
            }
            updateFightEnemies();
        break;

        case bStates.pAnimate:
            handleAnimations();
        break;

        case bStates.eTurn:
            player.move(defaultPos.x,defaultPos.y);

            fightEnemies[curEnemy].selAttack = eAttacks.basic; //fightEnemies[i].attacks[rand(0,fightEnemies[i].length-1)]
            curBattleState = bStates.eAnimate;
            
        break;

        case bStates.eAnimate:
            handleEnemyAnimations();
        break;
    }

}

//performs player's animations. the targeted enemy is passed in
function handleAnimations() {
    switch(curAttack) {
        case attacks.basic:
            basicAttack(target);
        break;

        case attacks.slash:
            slash(target);
        break
    }
}

//performs current enemy's animations. the current enemy is passed in
function handleEnemyAnimations() {
    switch(fightEnemies[curEnemy].selAttack) {
        case eAttacks.basic:
            eBasicAttack(curEnemy);
        break;
    }
}

function winBattle() {
    
    //some sort of win animation/screen will go here

    player.money += income;
    player.xp += income;
    income = 0;

    let tempPos = {
        x:worldEnemies[fightId].x,
        y:worldEnemies[fightId].y
    };

    worldEnemies.splice(fightId,1);
    player.move(tempPos.x,tempPos.y);
    
    globalState = states.world;
}

//checks the player's equipped items to show any unlocked attacks
function checkEquips() {
    let equips = inventory.equipSlots.children;
    for(let i = 0;i < equips.length;i++) {
        if(equips[i].slotType == catagories.weapon) {
            showAttacks(equips[i].item.attackUnlocks);
        }
    }
}

function showAttacks(unlocks) {
    for(let i = 0;i < unlocks.length;i++) {
        getComponentById(attacksKeys[unlocks[i]]).show = true;
    }
}

//sets attack's target and advanced the battle
function setTarget(targ) {
    target = targ;
    curBattleState = bStates.pAnimate;
}

function drawBattle() {
    player.draw();
    drawEnemies();
}

function drawBattleAbsolute() {
    drawUI();
}
const rarities = {
    common:0,
    uncommon:1,
    rare:2,
    epic:3,
    mystical:4,
    special:5
};

const rarityKeys = Object.keys(rarities);

const rarityColors = [
    "#7d7d7d",
    "#f0f0f0",
    "#f7412d",
    "#be00ff",
    "#00cdde",
    "#ded700"
];

const catagories = {
    all:-2,
    none:-1,
    weapon:0,
    singleUse:1,
    loot:2,
    armourAndEquipable:3,
    special:4
};

var itemIdCount = 0;

function getItemPositionById(id) {
    for(var i=0;i<player.inventory.length;i++) {
        if(player.inventory[i].id === id) {
            return i;
        }
    }
}

class BaseItem {
    constructor(name,toolTip,rarity) {
        this.name = name;
        this.toolTip = toolTip;
        this.rarity = rarity;
        this.id = itemIdCount;
        itemIdCount++;
        this.imageName = "debug0";
    }
}

BaseItem.prototype.sell = 0;
BaseItem.prototype.buy = 0;

BaseItem.prototype.category = catagories.none;

BaseItem.prototype.draw = function(ctx,x,y,sx=16,sy=16) {
    if(sx !== 16 || sy !== 16) {
        let tempImg = sprites[this.imageName].spr;
        ctx.drawImage(tempImg,0,0,tempImg.width,tempImg.height,x,y,sx,sy);
    } else {
        ctx.drawImage(sprites[this.imageName].spr,x,y);
    }
    
}
const equipTypes = {
    helmet:0,
    chestpiece:1,
    pants:2,
    boots:3,
    gloves:4,
    accessory:5
}

const equipTypesKeys = Object.keys(equipTypes);

var applyOneOffEffects = false;

class EquipableItem extends BaseItem {
    constructor(name,toolTip,rarity,equipType) {
        super(name,toolTip,rarity);
        this.equipType = equipType;
    }
}

EquipableItem.prototype.applyEffect = function() {
    player.statsMax.hp += 5;
}

EquipableItem.prototype.effectCondition = function() {
    if(applyOneOffEffects) {
        this.applyEffect();
    }
}

EquipableItem.prototype.category = catagories.armourAndEquipable;


class LootItem extends BaseItem {
    constructor(name,toolTip,rarity) {
        super(name,toolTip,rarity);
    }
}

LootItem.prototype.category = catagories.loot;
const effectTargets = {
    player:0,
    enemy:1,
    enemyAOE:2
};

const effectTargetsKeys = Object.keys(effectTargets);

var effects = {
    heal5:function(target) {
        target.trueStats.hp += 5;
    }
}

// pass a function that takes an entity into effect
class SingleUseItem extends BaseItem {
    constructor(name,toolTip,rarity,effect,effectType) {
        super(name,toolTip,rarity);
        this.effect = effect;
        this.effectType = effectType;
    }
}

SingleUseItem.prototype.category = catagories.singleUse;


class SpecialItem extends BaseItem {
    constructor(name,toolTip,rarity) {
        super(name,toolTip,rarity);
    }
}

SpecialItem.prototype.category = catagories.special;
const weaponTypes = {
    melee:0,
    ranged:1,
    magic:2,
    shield:3
};

const weaponTypesKeys = Object.keys(weaponTypes);

// pass array of attacks into attackUnlocks
class WeaponItem extends BaseItem {
    constructor(name,toolTip,rarity,weaponType,dmgBoost,attackUnlocks) {
        super(name,toolTip,rarity);
        this.weaponType = weaponType;
        this.dmgBoost = dmgBoost;
        this.attackUnlocks = attackUnlocks;
    }
}

WeaponItem.prototype.category = catagories.weapon;
WeaponItem.prototype.sell = 10;
class ItemListComponent extends Component {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        this.backgroundColor = "#00000000";
        this.canv = document.createElement("canvas");
        this.canv.width = w;
        this.canv.height = h;
        this.ctx = this.canv.getContext("2d");
        this.ctx.imageSmoothingEnabled = false;
        this.currentItems = [];
        this.spacing = 34;
    }
}

ItemListComponent.prototype.draw = function() {
    var items = this.currentItems;
    this.ctx.clearRect(0,0,this.w,this.h);
    this.ctx.fillStyle = "#999999";
    this.ctx.font = `8px pixelmix`;

    for(var i=0;i<items.length;i++) {
        // draw hover when hovered
        if(inventory.hoveredItem === i || inventory.selectedItem === i) {
            this.ctx.fillStyle = inventory.selectedItem === i ? colors.click :colors.hover;
            this.ctx.fillRect(0,i*this.spacing,this.w,this.spacing+2);
            this.ctx.fillStyle = "#999999";
        }
        // draw image
        items[i].draw(this.ctx,2,i*this.spacing + 2,32,32);
        // draw name
        if(items[i].name.length > 26) {
            // if name is long, split to 2 lines
            this.ctx.fillText(items[i].name.substring(0,30),40,(i+1)*this.spacing - 16);
            this.ctx.fillText(items[i].name.substring(30,items[i].name.length),40,(i+1)*this.spacing-8);
        } else {
            // if name is short, just draw
            this.ctx.fillText(items[i].name,40,(i+1)*this.spacing - 12);
        }
    }
    // draw list of items to component
    UICtx.drawImage(this.canv,this.x,this.y);
}

ItemListComponent.prototype.update = function() {
    if(inventory.mainComponent.show) {
        var items = player.inventory;
        this.currentItems = [];

        // find what items should be displayed
        for(var i=0;i<items.length;i++) {
            if(items[i].category === inventory.itemViewCategory || inventory.itemViewCategory === catagories.all) {
                this.currentItems.push(items[i]);
            }
        }

    
        items = this.currentItems;
        // deselect
        if((mousePress[0] && mousePos.x < 380) || keyPress[k.ESCAPE]) {
            inventory.selectedItem = null;
            var comp = getComponentById("itemViewer");
            while(comp.children.length>0) {
                comp.children[0].delete();
            }
        }
        // find if items are hovered over
        inventory.hoveredItem = null;
        for(var i=0;i<items.length;i++) {
            if(componentPoint({x:this.x,y:this.y + (i*this.spacing) + 1,w:this.w,h:this.spacing},mousePos)) {
                inventory.hoveredItem = i;
                // handle click
                if(mousePress[0]) {
                    inventory.selectedItem = i;
                    handleSelectedItemUI(this.currentItems[i]);
                }
            }
        }

        // arrow keys
        if(inventory.selectedItem !== null) {
            if(keyPress[k.UP]) {
                if(inventory.selectedItem > 0) {
                    inventory.selectedItem--;
                    handleSelectedItemUI(this.currentItems[inventory.selectedItem]);
                }
            }
            if(keyPress[k.DOWN]) {
                if(inventory.selectedItem < this.currentItems.length-1) {
                    inventory.selectedItem++;
                    handleSelectedItemUI(this.currentItems[inventory.selectedItem]);
                }
            }
        }

        // show/hide equip
        getComponentById("equipButton").show = false;
        if(inventory.equipSelect !== null && inventory.selectedItem !== null) {
            var slot = inventory.equipSlots.children[inventory.equipSelect];
            if(slot.slotType === this.currentItems[inventory.selectedItem].category) {
                getComponentById("equipButton").show = true;
            }
        }
        // show/hide unequip
        getComponentById("unequipButton").show = false;
        if(inventory.equipSelect !== null) {
            var slot = inventory.equipSlots.children[inventory.equipSelect];
            if(slot.item !== null) {
                getComponentById("unequipButton").show = true;
            }
        }
    }
}
const slotTypes = {
    equipable:catagories.armourAndEquipable,
    weapon:catagories.weapon
}

class equipmentSquare extends Component {
    constructor(x, y, w, h, slotType, sprite) {
        super(x, y, w, h);
        this.slotType = slotType;
        this.img = sprite.spr;
        this.item = null;
        this.showBackground = false;
    }
}

equipmentSquare.prototype.draw = function() {
    if(inventory.equipSelect === this.position) {
        UIRect(this.x,this.y,this.w,this.h,colors.click);
    }
    UIImageScaled(this.img, this.x, this.y, 2);
    if(this.item !== null) {
        var tempImg = sprites[this.item.imageName].spr;
        UICtx.drawImage(tempImg,0,0,tempImg.width,tempImg.height,this.x,this.y,this.w,this.h);
    }
}

equipmentSquare.prototype.update = function() {
    this.x = this.originalX + this.parent.x;
    this.y = this.originalY + this.parent.y;
    if(componentPoint(this,mousePos)) {
        if(mousePress[0]) {
            inventory.equipSelect = this.position;
        }
    }
}
var inventory = {
    mainComponent:null,
    itemViewCategory: catagories.all,
    itemViewCategoryName: "all",
    hoveredItem:null,
    selectedItem:null,
    equipSelect:null,
    equipSlots:null
};

var itemInvHeadings = [
    ["all",function(){inventory.itemViewCategory = catagories.all;inventory.itemViewCategoryName = "all";}],
    ["equipables",function(){inventory.itemViewCategory = catagories.armourAndEquipable;inventory.itemViewCategoryName = "equipables";}],
    ["weapons",function(){inventory.itemViewCategory = catagories.weapon;inventory.itemViewCategoryName = "weapons";}],
    ["usables",function(){inventory.itemViewCategory = catagories.singleUse;inventory.itemViewCategoryName = "usables";}],
    ["loot",function(){inventory.itemViewCategory = catagories.loot;inventory.itemViewCategoryName = "loot";}],
    ["special",function(){inventory.itemViewCategory = catagories.special;inventory.itemViewCategoryName = "special";}],
    ["misc.",function(){inventory.itemViewCategory = catagories.none;inventory.itemViewCategoryName = "misc.";}]
];

// switches UI in item viewer
function handleSelectedItemUI(item) {
    var comp = getComponentById("itemViewer");
    while(comp.children.length>0) {
        comp.children[0].delete();
    }
    // image
    var tempImg = new ImageComponent(80 - sprites[item.imageName].spr.width*3/2,0,sprites[item.imageName],3);
    tempImg.relativePosition = true;
    comp.addChild(tempImg);
    // rarity
    comp.addChild(new TextComponent(0,0,125,rarityColors[item.rarity],1,returnStr(rarityKeys[item.rarity])));
    // name
    comp.addChild(new TextComponent(0,0,125,"white",2,returnStr(item.name)));
    // sell price
    comp.addChild(new TextComponent(0,0,125,"#ded700",1,returnStr(`sell price: ${item.sell} currency`)));
    // tooltip
    var tt = new TextComponent(0,0,125,"white",1,returnStr(item.toolTip));
    tt.showBorder = true;
    comp.addChild(tt);

    // type specific info
    switch(item.category) {
        // weapon
        case catagories.weapon:
            // weapon type
            comp.addChild(new TextComponent(0,0,125,"white",1,returnStr(weaponTypesKeys[item.weaponType])));
            // damage boost
            if(item.weaponType === weaponTypes.magic) {
                comp.addChild(new TextComponent(0,0,125,"#2fbcbd",1,returnStr("damage: +" + item.dmgBoost)));
            } else if(item.weaponType !== weaponTypes.shield) {
                comp.addChild(new TextComponent(0,0,125,"white",1,returnStr("damage: +" + item.dmgBoost)));
            }
            // br
            var br = new Component(0,0,10,10);
            br.show = false;
            comp.addChild(br);
            // attack unlocks
            for(var i=0;i<item.attackUnlocks.length;i++) {
                if( i === 0 ) {
                    comp.addChild(new TextComponent(0,0,125,"white",1,returnStr(`enables attack${item.attackUnlocks.length > 1 ? "s" : ""}:`)));
                }
                comp.addChild(new TextComponent(0,0,125,"white",1,returnStr(attacksKeys[item.attackUnlocks[i]])));
            }
            break;
        // equipables
        case catagories.armourAndEquipable:
            comp.addChild(new TextComponent(0,0,125,"white",1,returnStr(equipTypesKeys[item.equipType])));
            break;
        // single use
        case catagories.singleUse:
            comp.addChild(new TextComponent(0,0,125,"white",1,returnStr("affects: " + effectTargetsKeys[item.effectType])));
            break;
    }
}

// creates inventory
function makeInventoryUI() {
    inventory.mainComponent = new HorizontalLayout(0,75,0,0);
    inventory.mainComponent.backgroundColor = colors.background + "55";
    inventory.mainComponent.show = false;

        // items section
        var itemsSection = new VerticalLayout(0,0,0,0);
        itemsSection.id = "itemDiv";
        itemsSection.backgroundColor = colors.background + "55";

            // buttons of type selection
            var typeBar = new HorizontalLayout(0,0,0,0);
            typeBar.id = "itemTypeDiv";

                // type buttons
                
                for(var i=0;i<itemInvHeadings.length;i++) {
                    var button = new Button(0,0,itemInvHeadings[i][1]);
                        button.addChild(new TextComponent(0,0,itemInvHeadings[i][0].length*7,"white",1,returnStr(itemInvHeadings[i][0])));
                    typeBar.addChild(button);
                }

            itemsSection.addChild(typeBar);

            // extra options
            var optionsBar = new HorizontalLayout(0,0,0,0);
                optionsBar.addChild(new TextComponent(0,0,150,"#777777",1,function(){return `viewing type: ${inventory.itemViewCategoryName}`}));
            itemsSection.addChild(optionsBar);

            // item list and viewer
            var itemListAndViewer= new HorizontalLayout(0,0,0,0);
            itemListAndViewer.showBackground = false;

                // list of items
                var itemList = new ItemListComponent(0,0,207,400);
                itemList.id = "itemList";
                itemList.showBackground = false;
                itemListAndViewer.addChild(itemList);

                // item viewer
                var itemViewer = new VerticalLayout(0,0,160,400);
                itemViewer.id = "itemViewer";
                itemViewer.adaptHeight = false;
                itemViewer.adaptWidth = false;
                itemViewer.showBackground = false;
                itemListAndViewer.addChild(itemViewer);

            itemsSection.addChild(itemListAndViewer);

        inventory.mainComponent.addChild(itemsSection);

        // equipment section
        var slots = new VerticalLayout(0,0,300,400);
        slots.showBackground = false;
        
            // slots
            inventory.equipSlots = new Component(0,0,300,300);
            inventory.equipSlots.showBackground = false;
            inventory.equipSlots.update = function() {
                if(mousePress[0] && mousePos.x > 380 && mousePos.y < 380 && !componentPoint(getComponentById("equipButton"),mousePos)) {
                    inventory.equipSelect = null;
                }
            }

                // accessory slot 1
                inventory.equipSlots.addChild(new equipmentSquare(10,30,32,32,slotTypes.equipable,sprites.slotAccesory));
                // weapon slot 1
                inventory.equipSlots.addChild(new equipmentSquare(10,100,32,32,slotTypes.weapon,sprites.slotWeapon));
                // weapon slot 2
                inventory.equipSlots.addChild(new equipmentSquare(10,140,32,32,slotTypes.weapon,sprites.slotWeapon));

            slots.addChild(inventory.equipSlots);

            // equip button
            var but = new Button(0,0,function(){
                var itemList = getComponentById("itemList");
                // get item in list
                var listItem = getItemPositionById(itemList.currentItems[inventory.selectedItem].id);
                // get item in slot
                var slotItemCache = inventory.equipSlots.children[inventory.equipSelect].item;
                // put in slot
                inventory.equipSlots.children[inventory.equipSelect].item = player.inventory[listItem];
                player.inventory.splice(listItem,1);
                // put in list
                if(slotItemCache !== null) {
                    player.inventory.splice(listItem,0,slotItemCache);
                }
                // clear info
                var comp = getComponentById("itemViewer");
                while(comp.children.length>0) {
                    comp.children[0].delete();
                }
            });
            but.id = "equipButton";
            but.addChild(new TextComponent(0,0,100,"white",2,function(){return `equip`}));
            slots.addChild(but);

            // unequip button
            but = new Button(0,0,function() {
                // get item in slot
                var slotItemCache = inventory.equipSlots.children[inventory.equipSelect].item;

                // put in list
                player.inventory.push(slotItemCache);

                // remove from slot
                inventory.equipSlots.children[inventory.equipSelect].item = null;
            });
            but.id = "unequipButton";
            but.addChild(new TextComponent(0,0,100,"white",2,function(){return `unequip`}));
            slots.addChild(but);

        inventory.mainComponent.addChild(slots);

    components.push(inventory.mainComponent);
}
var buildData = {
    inventory: false, // looking at inventory of tiles
    hotBarPosition: 0, // what hotbar is being veiwed
    position: 0, // position horizontally in hotbar
    type: 0, // visuals of the tile
    select: false, // if changed tile selection this frame
    dropDown: { showing: false, x: 0, y: 0, w: 0, h: 0 }, // info/collider for type dropdown
    mouseTile: null // what tile to display at cursor
};


var tilePalette = [];
var tilePaletteObjectStartPos;

var roomJSON; // json data for the current room, used when swapping global states

function handleBuild(isNewState) {
    if (isNewState) {
        // show html gui
        document.getElementById("buildGUI").style.display = "flex";

        // generate room link id inputs
        var htmlElem = document.getElementById("linkIDs");
        htmlElem.innerHTML = "";
        for(var i=0;i<worldObjects.length;i++) {
            if(worldObjects[i].constructor.name === "objectRoomLink") {
                addLinkUI(worldObjects[i],i);
                document.getElementById("linkID" + i).value = worldObjects[i].id;
                document.getElementById("linkRoom" + i).value = worldObjects[i].room;
            }
        }
    }

    // play mode
    if (keyPress[k.BACKSLASH]) {
        // remake room from what is in the editor
        roomJSON = getRoomJSON();
        parseRoom(roomJSON);
        // hide html gui
        document.getElementById("buildGUI").style.display = "none";

        globalState = states.world;
    }

    // camera movement
    if (keyDown[k.a]) { moveCamera(-5 / camera.zoom, 0); }
    if (keyDown[k.d]) { moveCamera(5 / camera.zoom, 0); }
    if (keyDown[k.w]) { moveCamera(0, -5 / camera.zoom); }
    if (keyDown[k.s]) { moveCamera(0, 5 / camera.zoom); }

    if (keyPress[k.EQUALS]) { camera.zoom++; }
    if (keyPress[k.MINUS]) { camera.zoom--; }
    camera.zoom += scroll;

    // inventory toggle
    // if (keyPress[k.e]) {
    //     buildData.inventory = !buildData.inventory;
    // }

    // hotbar manipulation
    // position movement
    if (keyPress[k.LEFT]) { buildData.position--; }
    if (keyPress[k.RIGHT]) { buildData.position++; }
    // type selecting
    if (keyPress[k.UP]) { buildData.type--; }
    if (keyPress[k.DOWN]) { buildData.type++; }
    // limit values to what tiles exist
    buildData.position = clamp(buildData.position, 0, tilePalette.length - 1);
    buildData.type = clamp(buildData.type, 0, tilePalette[buildData.position].typesAmount - 1);

    // find mouse position in grid
    var mPos = mousePosition();
    mPos.x = roundToGrid(mPos.x);
    mPos.y = roundToGrid(mPos.y);


    // select tile from hotbar
    if (mousePress[0]) {
        for (var i = 0; i < 20; i++) {
            if (rectpoint({ x: 18 + 34 * i, y: 18, w: 33, h: 33 }, mousePos)) {
                buildData.position = clamp(i + buildData.hotBarPosition * 20, 0, tilePalette.length - 1);
                buildData.select = true;
            }
        }
    }

    // show dropDown on hover 
    if (rectpoint({ x: 18 + 34 * buildData.position, y: 18, w: 33, h: 33 }, mousePos)) {
        var amount = tilePalette[buildData.position].typesAmount;
        if (amount > 1) {
            buildData.dropDown.showing = true;
            buildData.dropDown.x = (18 + buildData.position * 34);
            buildData.dropDown.y = 34 + (34 * amount) / 2;
            buildData.dropDown.w = 36;
            buildData.dropDown.h = amount * 34 + 4;
        }
    } else if (!rectpoint(buildData.dropDown, mousePos)) {
        buildData.dropDown.showing = false;
    }

    // select type from dropdown
    if (buildData.dropDown.showing && mousePress[0]) {
        for (var i = 0; i < tilePalette[buildData.position].typesAmount; i++) {
            if (rectpoint({ x: buildData.dropDown.x, y: 52 + i * 34, w: 33, h: 33 }, mousePos)) {
                buildData.type = i;
                buildData.select = true;
            }
        }
    }

    // place tile
    if (mouseDown[0]) {
        // if a tile wasn't just picked from the hotbar
        if (!buildData.select) {
            var xpos = mPos.x / 16;
            var ypos = mPos.y / 16;
            if (xpos === clamp(xpos, 0, tiles[0].length - 1) && ypos === clamp(ypos, 0, tiles.length - 1)) {
                if(buildData.position < tilePaletteObjectStartPos) {
                    tiles[ypos][xpos] = tileDefinitions[buildData.position](mPos.x, mPos.y, buildData.type);
                } else {
                    if(mousePress[0]) {
                        var func  = objectDefinitions[objDefKeys[buildData.position-tilePaletteObjectStartPos]];
                        if(func.length === 3) {
                            worldObjects.push(func(mPos.x, mPos.y, buildData.type));
                        } else {
                            worldObjects.push(func(mPos.x, mPos.y, buildData.type,[]));
                            // link id inputs
                            if(worldObjects[worldObjects.length-1].constructor.name === "objectRoomLink") {
                                addLinkUI(worldObjects[worldObjects.length-1],worldObjects.length-1);
                            }
                        }
                    }
                }
            }
        }
    } else {
        buildData.select = false;
    }

    // pick block from world
    if (mousePress[2]) {
        var xpos = mPos.x / 16;
        var ypos = mPos.y / 16;
        if (xpos === clamp(xpos, 0, tiles[0].length - 1) && ypos === clamp(ypos, 0, tiles.length - 1)) {
            buildData.position = tiles[ypos][xpos].tileID;
            buildData.type = tiles[ypos][xpos].type;
        }
    }

    // limit values to what tiles exist again because hotbar stuff
    buildData.position = clamp(buildData.position, 0, tilePalette.length - 1);
    buildData.type = clamp(buildData.type, 0, tilePalette[buildData.position].typesAmount - 1);
    // set tile to display at cursor
    if(buildData.position < tilePaletteObjectStartPos) {
        buildData.mouseTile = tileDefinitions[buildData.position](mPos.x, mPos.y, buildData.type);
    } else {
        var func  = objectDefinitions[objDefKeys[buildData.position-tilePaletteObjectStartPos]];
        if(func.length === 3) {
            buildData.mouseTile = func(mPos.x, mPos.y, buildData.type);
        } else {
            buildData.mouseTile = func(mPos.x, mPos.y, buildData.type,[]);
        }
    }

    for(var i=0;i<worldObjects.length;i++) {
        if(worldObjects[i].constructor.name === "objectRoomLink") {
            worldObjects[i].id = parseInt(document.getElementById("linkID" + i).value);
            worldObjects[i].room = document.getElementById("linkRoom" + i).value; 
        }
    }
}

function drawBuild() {
    drawRoomLimits();
    drawTiles();
    drawObjects();
    player.draw();

    if (buildData.mouseTile !== null) {
        buildData.mouseTile.draw();
    }
}

function drawBuildAbsolute() {
    scaleDefault = 2;
    if (buildData.inventory) {
        // show inventory here
    } else {
        rect(cw/2, 18, cw, 36, "#555555");
        // go through the tiles in the current hotbar, and draw them to the ui
        for (var i = buildData.hotBarPosition * 20; i < buildData.hotBarPosition * 20 + 20; i++) {
            if (tilePalette[i] !== undefined) {
                
                if (i === buildData.position) {
                    // highlight selected tile
                    rect(18 + i * 34, 18, 36, 36, "#999999");
                    if (buildData.dropDown.showing) {
                        // draw dropdown background
                        rect(buildData.dropDown.x, buildData.dropDown.y, buildData.dropDown.w, buildData.dropDown.h, "#999999");
                        // draw tile variations in background
                        for (var j = 0; j < tilePalette[i].typesAmount; j++) {
                            tilePalette[i].y = 18 + (j + 1) * 34;
                            tilePalette[i].type = j;
                            if(i<tilePaletteObjectStartPos) {
                                tilePalette[i].draw();
                            } else {
                                tilePalette[i].compressedDraw();
                            }
                        }
                    }
                    tilePalette[i].type = buildData.type;
                }

                // draw tile in pallette
                tilePalette[i].x = 18 + i * 34;
                tilePalette[i].y = 18;
                if(i<tilePaletteObjectStartPos) {
                    tilePalette[i].draw();
                } else {
                    tilePalette[i].compressedDraw();
                }
                tilePalette[i].type = 0;
            }
        }
    }
    scaleDefault = 1;
}
function handleTitleScreen(isNewState) {
    
}

function drawTitleScreen() {
    text("RPG game lol example text aaaaaaaaaaaaaaaaa",100,200,"green",4,400);
    
}
function handleWorld(isNewState) {
    if (isNewState) {
        toggleBattleUI(false);
        camera.zoom = 2;
        player.setCamera();

        //temporary test enemy stuff dont worry about it :)
        worldEnemies.push(new Enemy(250,50,24,24,50,[0,0],0));
        if(rectrect(worldEnemies[0],player)) {
            worldEnemies = [];
        }
    }
    updateComponents();

    updateEnemies();
    player.update();

    updateObjects();

    // build mode
    if (keyPress[k.BACKSLASH]) {
        globalState = states.build;
    }

    camera.zoom += scroll/5;
}

function drawWorld() {
    drawRoomLimits();
    // floor
    if(roomInfo.layers.floor !== null) {imgIgnoreCutoff({spr:roomInfo.layers.floor},roomInfo.width*8-8,roomInfo.height*8-8);}
    drawEnemies();
    player.draw();
    //walls
    if(roomInfo.layers.walls !== null) {imgIgnoreCutoff({spr:roomInfo.layers.walls},roomInfo.width*8-8,roomInfo.height*8-8);}
    drawBlack();
}

function drawWorldAbsolute() {
    drawUI();
}
// rounds to nearest 16
function roundToGrid(number) {
    return Math.round(number / 16) * 16;
}

// clamps a value between min and max
function clamp(value, min, max) {
    return Math.min(max, Math.max(min, value));
}

// linear interpolation towards somewhere
function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }

// returns a new value with friction applied
function friction(value, amount) {
    if (value > 0) { value -= amount; }
    if (value < 0) { value += amount; }
    if (Math.abs(value) < amount * 2) { value = 0; }
    return value;
}

var tau = Math.PI * 2;
var pi = Math.PI;
// returns a new angle that gets closer to the target angle
function turn(cur, target, speed) {
    if (target < 0) { target = tau + target; }
    if ((cur % tau) > target) {
        if ((cur % tau) - target > pi) {
            cur += speed;
        } else {
            cur -= speed;
        }
    } else {
        if (target - (cur % tau) > pi) {
            cur -= speed;
        } else {
            cur += speed;
        }
    }
    if (Math.abs(cur - target) < speed * 1.1) {
        cur = target;
    }
    if (cur > tau) { cur = cur - tau; }
    if (cur < 0) { cur = tau + cur; }
    return cur;
}
// returns a 3x3 matrix of coordinates to check for collisions in
function getColliisons(entity) {
    // find position of entity in tile array
    var xpos = roundToGrid(entity.x) / 16;
    var ypos = roundToGrid(entity.y) / 16;
    xpos = clamp(xpos, 1, roomInfo.width - 2);
    ypos = clamp(ypos, 1, roomInfo.height - 2);
    // find tiles around entity
    var returnArray = [];
    for (var yy = -1; yy < 2; yy++) {
        returnArray.push([]);
        for (var xx = -1; xx < 2; xx++) {
            returnArray[yy + 1][xx + 1] = [xpos + xx, ypos + yy];
        }
    }
    return returnArray;
}

function colliding(entity, tilesArray) {
    var halfW = entity.w / 2;
    var halfH = entity.h / 2;

    // if hitting the wall, entity is colliding
    if (entity.x - halfW < -8 || entity.y - halfH < -8 || entity.x + halfW > roomInfo.width * 16 - 8 || entity.y + halfH > roomInfo.height * 16 - 8) { return true; }

    // go through near tiles
    for (var yy = 0; yy < tilesArray.length; yy++) {
        for (var xx = 0; xx < tilesArray[0].length; xx++) {
            var pos = tilesArray[yy][xx];

            // if the tile effect is collide, check for collision
            if (tiles[pos[1]][pos[0]].effect === effects.colliding) {
                if (rectrect(entity, tiles[pos[1]][pos[0]])) {
                    return true;
                }
            }
            
        }
    }

    for(var o=0;o<worldObjects.length;o++) {
        if(rectrect(entity,worldObjects[o])) {
            return true;
        }
    }

    return false;
}
// make tile layers
function makeTileLayers() {
    globalState = states.world;
    // store drawing info
    var camCache = { x: camera.x, y: camera.y };
    var drawModeCache = drawMode;
    var ctxCache = curCtx;
    camera.x = 8;
    camera.y = 8;
    drawMode = 0;
    absDraw = true;

    // draw tiles once

    // create canvas to draw layer to
    var tempCanv = document.createElement("canvas");
    tempCanv.width = roomInfo.width * 16;
    tempCanv.height = roomInfo.height * 16;
    var tempCtx = tempCanv.getContext("2d");
    curCtx = tempCtx;

    // create canvas to draw a tile to
    var mergeCanvas = document.createElement("canvas");
    mergeCanvas.width = 16;
    mergeCanvas.height = 16;
    mergeCtx = mergeCanvas.getContext("2d");

    var keys = Object.keys(roomInfo.layers);

    for(var l=0;l<keys.length;l++) {
        // draw pass
        for (var y = 0; y < tiles.length; y++) {
            for (var x = 0; x < tiles[0].length; x++) {
                if(tiles[y][x].layer === l) {
                    tiles[y][x].draw();
                }
            }
        }

        // merge pass
        for (var y = 0; y < tiles.length; y++) {
            for (var x = 0; x < tiles[0].length; x++) {
                if(tiles[y][x].layer === l) {
                    // top
                    if (y > 0) {
                        if (tiles[y][x].mergesWith.includes(tiles[y - 1][x].tileID)) {
                            curCtx = mergeCtx;
                            var paletteTile = tilePalette[tiles[y][x].tileID];
                            paletteTile.x = 0;
                            paletteTile.y = 0;
                            paletteTile.type = tiles[y][x].type;
                            mergeCtx.clearRect(0, 0, 16, 16);
                            paletteTile.draw();
                            for (var i = 0; i < 16; i++) {
                                mergeCtx.clearRect(i, 0, 1, rand(12, 15));
                            }
                            curCtx = tempCtx;
                            img({ spr: mergeCanvas }, x * 16, (y - 1) * 16);
                        }
                    }
                    // bottom
                    if (y < tiles.length - 1) {
                        if (tiles[y][x].mergesWith.includes(tiles[y + 1][x].tileID)) {
                            curCtx = mergeCtx;
                            var paletteTile = tilePalette[tiles[y][x].tileID];
                            paletteTile.x = 0;
                            paletteTile.y = 0;
                            paletteTile.type = tiles[y][x].type;
                            mergeCtx.clearRect(0, 0, 16, 16);
                            paletteTile.draw();
                            for (var i = 0; i < 16; i++) {
                                mergeCtx.clearRect(i, rand(1, 4), 1, 16);
                            }
                            curCtx = tempCtx;
                            img({ spr: mergeCanvas }, x * 16, (y + 1) * 16);
                        }
                    }
                    // left
                    if (x > 0) {
                        if (tiles[y][x].mergesWith.includes(tiles[y][x - 1].tileID)) {
                            curCtx = mergeCtx;
                            var paletteTile = tilePalette[tiles[y][x].tileID];
                            paletteTile.x = 0;
                            paletteTile.y = 0;
                            paletteTile.type = tiles[y][x].type;
                            mergeCtx.clearRect(0, 0, 16, 16);
                            paletteTile.draw();
                            for (var i = 0; i < 16; i++) {
                                mergeCtx.clearRect(0, i, rand(12, 15), 1);
                            }
                            curCtx = tempCtx;
                            img({ spr: mergeCanvas }, (x - 1) * 16, y * 16);
                        }
                    }
                    // right
                    if (x < tiles[0].length - 1) {
                        if (tiles[y][x].mergesWith.includes(tiles[y][x + 1].tileID)) {
                            curCtx = mergeCtx;
                            var paletteTile = tilePalette[tiles[y][x].tileID];
                            paletteTile.x = 0;
                            paletteTile.y = 0;
                            paletteTile.type = tiles[y][x].type;
                            mergeCtx.clearRect(0, 0, 16, 16);
                            paletteTile.draw();
                            for (var i = 0; i < 16; i++) {
                                mergeCtx.clearRect(rand(1, 4), i, 16, 1);
                            }
                            curCtx = tempCtx;
                            img({ spr: mergeCanvas }, (x + 1) * 16, y * 16);
                        }
                    }
                }
            }
        }

        // shadow pass
        if(l === layer.wall) {
            for (var y = 0; y < tiles.length; y++) {
                for (var x = 0; x < tiles[0].length; x++) {
                    if(tiles[y][x].layer === layer.wall) {
                        var shadowKey = "";
                        // top
                        if (y > 0) {
                            shadowKey += tiles[y-1][x].layer !== layer.wall ? "1" : "0";
                        } else { shadowKey += "0";}
                        // right
                        if (x < tiles[0].length - 1) {
                            shadowKey += tiles[y][x+1].layer !== layer.wall ? "1" : "0";
                        } else { shadowKey += "0";}
                        // bottom
                        if (y < tiles.length - 1) {
                            shadowKey += tiles[y+1][x].layer !== layer.wall ? "1" : "0";
                        } else { shadowKey += "0";}
                        // left
                        if (x > 0) {
                            shadowKey += tiles[y][x-1].layer !== layer.wall ? "1" : "0";
                        } else { shadowKey += "0";}
                        var cache = tiles[y][x];
                        tempCtx.drawImage(shadows[shadowKey],cache.x-3,cache.y-3);
                    }
                }
            }
        }

        // object pass
        for (var i = 0; i < worldObjects.length; i++) {
            if(worldObjects[i].layer === l) {
                worldObjects[i].draw();
            }
        }
        

        // cache layer image, so drawing every frame will be faster
        roomInfo.layers[keys[l]] = new Image();
        roomInfo.layers[keys[l]].src = tempCanv.toDataURL("image/png");
        tempCtx.clearRect(0,0,tempCanv.width,tempCanv.height);
    }

    

    // reset drawing info
    camera.x = camCache.x;
    camera.y = camCache.y;
    drawMode = drawModeCache;
    curCtx = ctxCache;
    absDraw = false;

    player.setCamera();
    document.getElementById("load").style.display = "none";
}

var shadowColor = "#000022";
var shadowCanv = document.createElement("canvas");
shadowCanv.width = 22;
shadowCanv.height = 22;
var shadowCtx = shadowCanv.getContext("2d");
var shadows = {};

function generateShadows() {
    for(var i=0;i<16;i++) {
        var key = i.toString(2);
        while(key.length<4) {
            key = "0" + key;
        }
        shadows[key] = null;
    }
    var keys = Object.keys(shadows);
    for(var i=0;i<16;i++) {
        var str = keys[i];
        // top left
        if(str[0]==="1" && str[3]==="1") {
            drawShadow([[0,0,0,0],[1,1,2,2],[0,0,3,3]]);
        }
        // top
        if(str[0]==="1") {
            drawShadow([[3,2,16,1],[3,1,16,1],[3,0,16,1]]);
        }
        // right
        if(str[1]==="1") {
            drawShadow([[19,3,1,16],[20,3,1,16],[21,3,1,16]]);
        }
        // top right
        if(str[0]==="1" && str[1]==="1") {
            drawShadow([[0,0,0,0],[19,1,2,2],[19,0,3,3]]);
        }
        // bottom
        if(str[2]==="1") {
            drawShadow([[3,19,16,1],[3,20,16,1],[3,21,16,1]]);
        }
        // bottom right
        if(str[2]==="1" && str[1]==="1") {
            drawShadow([[0,0,0,0],[19,19,2,2],[19,19,3,3]]);
        }
        // left
        if(str[3]==="1") {
            drawShadow([[2,3,1,16],[1,3,1,16],[0,3,1,16]]);
        }
        // bottom left
        if(str[2]==="1" && str[3]==="1") {
            drawShadow([[0,0,0,0],[1,19,2,2],[0,19,3,3]]);
        }

        shadows[keys[i]] = new Image();
        shadows[keys[i]].src = shadowCanv.toDataURL("image/png");
        shadowCtx.clearRect(0,0,22,22);
    }
}

function drawShadow(arr) {
    shadowCtx.fillStyle = shadowColor+"66";
    shadowCtx.fillRect(arr[0][0],arr[0][1],arr[0][2],arr[0][3]);
    shadowCtx.fillStyle = shadowColor+"44";
    shadowCtx.fillRect(arr[1][0],arr[1][1],arr[1][2],arr[1][3]);
    shadowCtx.fillStyle = shadowColor+"22";
    shadowCtx.fillRect(arr[2][0],arr[2][1],arr[2][2],arr[2][3]);
}
var worldObjects = [];

class baseObject {
    constructor(x,y,w,h,type,definitionKey) {
        this.x = x + this.offSetX;
        this.y = y + this.offSetY;
        this.h = h;
        this.w = w;
        this.imageName = "debug";
        this.type = type;
        this.definitionKey = definitionKey;
        this.layer = layer.wall;
    }
}

baseObject.prototype.typesAmount = 1; // amount of object visual variations

baseObject.prototype.exportArgs = undefined;

baseObject.prototype.offSetX = 0;
baseObject.prototype.offSetY = 0;

baseObject.prototype.draw = function() {
    img(sprites[`${this.imageName}${this.type}`],this.x,this.y);
}

baseObject.prototype.compressedDraw = function() {
    var spr = sprites[`${this.imageName}${this.type}`].spr;
    canvases.ctx.drawImage(spr,0,0,spr.width,spr.height,this.x-16,this.y-16,32,32);
} 

baseObject.prototype.update = function() {}

function drawObjects() {
    for(var i=0;i<worldObjects.length;i++) {
        worldObjects[i].draw();
    }
}

function updateObjects() {
    for(var i=0;i<worldObjects.length;i++) {
        worldObjects[i].update();
    }
}
class objectTree extends baseObject {
    constructor(x,y,type,defName) {
        super(x,y,20,20,type,defName);
        this.imageName = "tree";
    }
}

objectTree.prototype.typesAmount = 2;
class objectHouseSmall extends baseObject {
    constructor(x,y,type,defName) {
        super(x,y,64,48,type,defName);
        this.imageName = "houseSmall";
    }
}

objectHouseSmall.prototype.offSetX = 8;

objectHouseSmall.prototype.draw = function() {
    img(sprites[`${this.imageName}${this.type}`],this.x,this.y);
}
class objectRoomLink extends baseObject {
    constructor(x,y,type,defName,args) {
        super(x,y,-16,-16,type,defName);
        this.imageName = "link";
        this.id = args[0];  
        this.room = args[1];
        this.playerOn = true;
    }
}

objectRoomLink.prototype.typesAmount = 2;

objectRoomLink.prototype.update = function() {
    if(dist(this,player) < 10) {
        if(this.playerOn === false) {
            loadRoom(rooms[this.room],this.id);
        }
    } else {
        this.playerOn = false;
    }
}

objectRoomLink.prototype.draw = function() {
    img(sprites[`${this.imageName}${this.type}`],this.x,this.y);
    if(globalState === states.build) {
        text(this.id===undefined?"not set" : this.id,this.x-8,this.y-8,"black",2);
    }
}


objectRoomLink.prototype.exportArgs = function() {
    return [this.id,this.room]
}

function addLinkUI(obj,index) {
    var div = document.createElement("div");
    var span = document.createElement("span");
    span.innerText = obj.x + "," + obj.y + ":";
    div.appendChild(span);
    var input = document.createElement("input");
    input.type = "number";
    input.id = "linkID" + index;
    div.appendChild(input);

    input = document.createElement("input");
    input.type = "text";
    input.id = "linkRoom" + index;
    div.appendChild(input);
    
    document.getElementById("linkIDs").appendChild(div);
}
var objectDefinitions = {
    tree:function (x, y, type) { return new objectTree(x, y, type, "tree"); },
    houseSmall:function (x, y, type) { return new objectHouseSmall(x, y, type, "houseSmall"); },
    link:function (x, y, type, args) { return new objectRoomLink(x, y, type, "link", args); }
};

var objDefKeys = Object.keys(objectDefinitions);
// enum for rooms, each room key name is the name of its JSON file without .json, and its value is its position in the object
var rooms = {
    test: 0,
    default: 1,
    starterVillage: 2
}

var room = rooms.default;

var roomInfo = {
    width: 0,
    height: 0,
    layers: { // images for each layer
        floor: null,
        walls: null
    }
}

// draws a rectangle of the room size
function drawRoomLimits() {
    rect(roomInfo.width * 8 - 8, roomInfo.height * 8 - 8, roomInfo.width * 16, roomInfo.height * 16, "#303030");
}

function drawBlack() {
    rect(- cw / 4 - 8, roomInfo.height * 8 - 8, cw / 2, ch, "#000000");
    rect((roomInfo.width - 1) * 16 + cw / 4 + 8, roomInfo.height * 8 - 8, cw / 2, ch, "#000000");
    rect(roomInfo.width * 8 - 8, - ch / 4 - 8, cw, ch / 2, "#000000");
    rect(roomInfo.width * 8 - 8, (roomInfo.height - 1) * 16 + ch / 4 + 8, cw, ch / 2, "#000000");
}

// creates a room of 0.0s with size set in html GUI
function addRoom() {
    tiles = [];
    roomInfo.width = document.getElementById("width").value;
    roomInfo.height = document.getElementById("height").value;
    for (var i = 0; i < roomInfo.height; i++) {
        tiles.push([]);
        for (var j = 0; j < roomInfo.width; j++) {
            tiles[i].push(tileDefinitions[0](j * 16, i * 16, 0));
        }
    }
    var htmlElem = document.getElementById("linkIDs");
    htmlElem.innerHTML = "";
    worldObjects = [];
}

function loadRoom(room,id=undefined) {
    document.getElementById("load").style.display = "block";
    globalState = states.loading;
    // get link of json file
    var link = "assets/roomFiles/" + Object.keys(rooms)[room] + ".json";
    // get room file and load from it 
    fetch(link).then((response) => response.json().then((data) => { parseRoom(data,id); }));
}

// export room to json
function getRoomJSON() {
    var roomObj = {};

    // set width and height
    roomObj.width = roomInfo.width;
    roomObj.height = roomInfo.height;

    // add tiles
    var tilesArray = [];
    for (var y = 0; y < tiles.length; y++) {
        var str = "";
        for (var x = 0; x < tiles[0].length; x++) {
            // add id.type
            str += `${tiles[y][x].tileID}.${tiles[y][x].type},`;
        }
        // add string minus last comma
        tilesArray.push(str.substring(0, str.length - 1));
    }
    roomObj.tiles = tilesArray;

    var roomObjcts = [];

    for(var i=0;i<worldObjects.length;i++) {
        var wo = worldObjects[i];
        if(wo.exportArgs !== undefined) {
            roomObjcts.push([wo.definitionKey,(wo.x-wo.offSetX)/16 ,(wo.y-wo.offSetY)/16,wo.type,wo.exportArgs()]);
        } else {
            roomObjcts.push([wo.definitionKey,(wo.x-wo.offSetX)/16 ,(wo.y-wo.offSetY)/16,wo.type]);
        }
    }

    // add objects
    roomObj.roomObjects = roomObjcts;

    return roomObj;
}

// load room from json
function parseRoom(json,id) {
    tiles = [];
    worldObjects = [];
    roomInfo.width = json.width;
    roomInfo.height = json.height;
    var t = json.tiles;
    // go through array of strings
    for (var y = 0; y < t.length; y++) {
        tiles.push([]);
        // spilt string on commas to get tiles
        tt = t[y].split(",");
        // go through tiles
        for (var x = 0; x < tt.length; x++) {
            // get tileId and type component of string
            var ttt = tt[x].split(".");
            // add tile tileID at x,y with type type
            tiles[y].push(tileDefinitions[parseInt(ttt[0])](x * 16, y * 16, parseInt(ttt[1])));
        }
    }

    var o = json.roomObjects;
    // go through array of strings
    for (var i = 0;i < o.length; i++) {
        var oo = o[i];
        if(oo.length === 4) {
            worldObjects.push(objectDefinitions[oo[0]](oo[1]*16,oo[2]*16,oo[3]));
        } else {
            worldObjects.push(objectDefinitions[oo[0]](oo[1]*16,oo[2]*16,oo[3],oo[4]));
        }
    }

    makeTileLayers();

    player.x = 0;
    player.y = 0;

    if(id !== undefined) {
        for(var i=0;i<worldObjects.length;i++) {
            if(worldObjects[i].constructor.name === "objectRoomLink") {
                if(worldObjects[i].id === id) {
                    player.x = worldObjects[i].x;
                    player.y = worldObjects[i].y;
                }
            }
        }
    }
}

// download rooms
document.getElementById("name").onkeydown = function (e) {
    if (e.keyCode === k.ENTER) {
        downloadRoom();
    }
}
function downloadRoom() {
    var exportObj = getRoomJSON();

    // create download link
    var link = document.createElement("a");
    link.download = document.getElementById("name").value;
    var blob = new Blob([JSON.stringify(exportObj, null, "\t")], { type: "application/json" });
    link.href = URL.createObjectURL(blob);

    // click the link
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
    link.dispatchEvent(e);
}
var tiles = [];

var effects = {
    none:0,
    colliding:1,
    speedUp:2
};

var layer = {
    ground:0,
    wall:1
};

class BaseTile {
    constructor(x,y,type,tileID,layer) {
        this.x = x;
        this.y = y;
        this.w = 16;
        this.h = 16;
        this.tileID  = tileID;
        this.type = type;
        this.layer = layer;
        this.imageName = "debug";
    }
}
BaseTile.prototype.typesAmount = 1; // amount of tile visual variations

BaseTile.prototype.mergesWith = []; // what tile this with visually merge with

BaseTile.prototype.effect = effects.none; // what effect this tile does

BaseTile.prototype.draw = function() {
    img(sprites[`${this.imageName}${this.type}`],this.x,this.y);
}

function drawTiles() {
    for(var y=0;y<tiles.length;y++) {
        for(var x=0;x<tiles[0].length;x++) {
            tiles[y][x].draw();
        }
    }
}
class BaseWall extends BaseTile { 
    constructor(x,y,type,tileID) {
        super(x,y,type,tileID,layer.wall);
    } 
}

BaseWall.prototype.effect = effects.colliding;
class tileGrass extends BaseTile {
    constructor(x,y,type,tileID) {
        super(x,y,type,tileID,layer.ground);
        this.imageName = "grass";
    }
}
tileGrass.prototype.typesAmount = 2;
tileGrass.prototype.mergesWith = [0,1];
class tilePath extends BaseTile {
    constructor(x,y,type,tileID) {
        super(x,y,type,tileID,layer.ground);
        this.imageName = "path";
    }
}
tilePath.prototype.typesAmount = 1;

tilePath.prototype.effect = effects.speedUp;
class wallBrick extends BaseWall {
    constructor(x,y,type,tileID) {
        super(x,y,type,tileID);
        this.imageName = "brick";
    }
}
wallBrick.prototype.typesAmount = 4;
var tileDefinitions = [
    // 0 = grass
    function (x, y, type) { return new tileGrass(x, y, type, 0); },
    // 1 = path
    function (x, y, type) { return new tilePath(x, y, type, 1); },
    // 2 = bricks
    function (x, y, type) { return new wallBrick(x, y, type, 2); }
];
// files paths of image files
images = [
    "assets/images/",
    [
        "tiles/",
        "debug0.png",
        "grass0.png",
        "grass1.png",
        "path0.png",
        "brick0.png",
        "brick1.png",
        "brick2.png",
        "brick3.png"
    ],
    [
        "objects/",
        "tree0.png",
        "tree1.png",
        "link0.png",
        "link1.png",
        "houseSmall0.png"
    ],
    "tempPlayer.png",
    "tempEnemy.png",
    "slotAccesory.png",
    "slotWeapon.png"
];

// files paths of audio files
audio = [
    "assets/audio/",
    [
        "music/",
        "loop1.mp3"
    ]
];

// enum kinda thing for game states
var states = {
    titleScreen: 0,
    world: 1,
    battle: 2,
    cutscene: 3,
    loading: 4,
    build: 99
}

var drawCount = 0;
var updateCount = 0;

// current state
var globalState = states.world;
// last state
var lastGlobalState;

function update() {
    // if this is the first time updating in this state
    var newState = false;

    if (lastGlobalState !== globalState) {
        newState = true;
    }
    lastGlobalState = globalState;

    // run code depending on what state the game is in
    switch (globalState) {
        // title state
        case states.titleScreen:
            handleTitleScreen(newState);
            break;
        // in world
        case states.world:
            handleWorld(newState);
            break;
        //in a battle
        case states.battle:
            handleBattle(newState);
            break;
        case states.loading:
            break;
        // build mode
        case states.build:
            handleBuild(newState);
            break;
        // if state is set to something that doesn't exist
        default:
            console.warn("in unknown state");
            break;
    }
    updateCount++;
}

function draw() {
    switch (globalState) {
        // title state
        case states.titleScreen:
            drawTitleScreen();
            break;
        // in world
        case states.world:
            drawWorld();
            break;
        // in a battle
        case states.battle:
            drawBattle();
            break;
        // build mode
        case states.build:
            drawBuild();
            break;
    }
    drawCount++;
}

function absoluteDraw() {
    switch (globalState) {
        // title state
        case states.titleScreen:
            break;
        // in world
        case states.world:
            drawWorldAbsolute();
            break;
        // in a battle
        case states.battle:
            drawBattleAbsolute();
            break;
        // build mode
        case states.build:
            drawBuildAbsolute();
            break;
    }
}

function onAssetsLoaded() {
    generateShadows();
    for (var i = 0; i < tileDefinitions.length; i++) {
        tilePalette.push(tileDefinitions[i](0, 0, 0));
    }

    tilePaletteObjectStartPos = tilePalette.length;

    for (var i = 0; i < objDefKeys.length; i++) {
        if(objectDefinitions[objDefKeys[i]].length === 3) {
            tilePalette.push(objectDefinitions[objDefKeys[i]](0, 0, 0));
        } else {
            tilePalette.push(objectDefinitions[objDefKeys[i]](0, 0, 0,[]));
        }
    }


    // ui testing
    // var layoutComponent = new HorizontalLayout(10,50,0,70);
    // layoutComponent.padding = 6;
    // layoutComponent.addChild(new Component(0,55,20,20));
    // var layoutComponent2 = new HorizontalLayout(10,50,0,60);
    // layoutComponent2.spacing = 10;
    // layoutComponent2.showBorder = false;
    // layoutComponent2.showShadow = false;
    // layoutComponent2.addChild(new Component(0,60,30,30));
    // var but = new Button(0,60,function(){console.log(true);});
    // but.id = "button";
    // but.addChild(new ImageComponent(0,0,sprites.grass0));
    // but.addChild(new TextComponent(0,0,30,"white",1,function(){return "click me!";}));
    // but.addChild(new Component(0,0,40,20));
    // layoutComponent2.addChild(but);
    // layoutComponent2.addChild(new HorizontalLayout(0,60,100,30));
    // layoutComponent2.addChild(new ImageComponent(0,40,sprites.tempPlayer));
    // layoutComponent2.children[2].addChild(new TextComponent(0,70,90,"white",1,function(){return "this is a test lol";}));
    // layoutComponent.addChild(layoutComponent2);
    // components.push(layoutComponent);

    cw = canvases.cvs.width;
    ch = canvases.cvs.height;

    makeStatsUI();

    makeBattleUI();

    makeInventoryUI();

    setType(sounds.loop1,"bgm");

    play(sounds.loop1);

    // test items
    player.inventory.push(new WeaponItem("test","this is a tooltip",rarities.epic,weaponTypes.melee,2,[attacks.basic]));
    player.inventory.push(new WeaponItem("sdaf lkj hgsafdolih fdsa lkjhsadfl kjfhdsalkjhs afdlkuhfd salkusauhf","this is a tooltip",rarities.uncommon,weaponTypes.magic,5465452,[attacks.basic,attacks.slash]));
    player.inventory[1].imageName = "tempEnemy";
    player.inventory.push(new LootItem("loot item","tooltips yall",rarities.common));
    player.inventory.push(new EquipableItem("EquipableItem item","According to all known laws of aviation, there is no way a bee should be able to fly. Its wings are too small to get its fat little body off the ground. The bee, of course, flies anyway because bees don't care what humans think is impossible. Yellow, black. Yellow, black. Yellow, black. Yellow, black. Ooh, black and yellow! Let's shake it up a little. Barry! Breakfast is ready! Ooming! Hang on a second. Hello?",rarities.rare,equipTypes.boots));
    player.inventory.push(new SingleUseItem("SingleUseItem item","!@#$%^&*()_+{|}::<>?[\\];',/.`~",rarities.mystical,effects.heal5,effectTargets.player));
    player.inventory[4].imageName = "path0";
    player.inventory.push(new SpecialItem("AAAAAAAAAAA","eh",rarities.special));

    loadRoom(rooms.starterVillage);
}
setup(60);
